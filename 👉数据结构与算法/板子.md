### *辗转相除*#递推#

int gcd(int a,int b){
	if(b==0)return a;
	else return gcd(b,a%b);
}

### *printf的用法大全*

1．转换说明符
      %a(%A)     浮点数、十六进制数字和p-(P-)记数法(C99)
      %c             字符
      %d             有符号十进制整数
      %f              浮点数(包括float和double)
      %e(%E)     浮点数指数输出[e-(E-)记数法]
      %g(%G)     浮点数不显无意义的零"0"
      %i              有符号十进制整数(与%d相同)
      %u             无符号十进制整数
      %o             八进制整数    e.g.     0123
      %x(%X)      十六进制整数<?xml:namespace prefix = st1 />()   e.g.   0x1234
      %p             指针
      %s             字符串
      %%            "%"

2．标志
      左对齐："-"   e.g.   "%-20s"
      右对齐："+" e.g.   "%+20s"
      空格：若符号为正，则显示空格，负则显示"-"   e.g.   "% "      
      #：对c,s,d,u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；
           对e,g,f 类当结果有小数时才给出小数点。

3．格式字符串（格式）
      ［标志］［输出最少宽度］［．精度］［长度］类型 
     "％-md" ：左对齐，若m比实际少时，按实际输出。
     "%m.ns"：输出m位，取字符串(左起)n位，左补空格，当n>m or m省略时m=n
                      e.g.    "%7.2s"   输入CHINA
                                 　           输出"     CH"
     "%m.nf"：输出浮点数，m为宽度，n为小数点右边数位
                      e.g.    "%"    输入3852.99
                                               输出3853.0 
      长度：为ｈ短整形量,ｌ为长整形量

**printf的格式控制的完整格式：**
% - .n l或h 格式字符
下面对组成格式说明的各项加以说明：
①%：表示格式说明的起始符号，不可缺少。
②-：有-表示左对齐输出，如省略表示右对齐输出。
③0：有0表示指定空位填0,如省略表示指定空位不填。
④m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。
⑤l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。

 

一个h表示short，即short int

两个h表示short short，即 char。
%hhx用于输出char
%hx用于输出short int.

**格式字符** 
格式字符用以指定输出项的数据类型和输出格式。
①d格式：用来输出十进制整数。有以下几种用法：
%d：按整型数据的实际长度输出。
%md：m为指定的输出字段的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。
%ld：输出长整型数据。
②o格式：以无符号八进制形式输出整数。对长整型可以用"%lo"格式输出。同样也可以指定字段宽度用“%mo”格式输出。
例：
   main()
   { int a = -1;
     printf("%d, %o", a, a);
   }
运行结果：-1,177777
程序解析：-1在内存单元中（以补码形式存放）为(1111111111111111)2，转换为八进制数为(177777)8。
③x格式：以无符号十六进制形式输出整数。对长整型可以用"%lx"格式输出。同样也可以指定字段宽度用"%mx"格式输出。
④u格式：以无符号十进制形式输出整数。对长整型可以用"%lu"格式输出。同样也可以指定字段宽度用“%mu”格式输出。
⑤c格式：输出一个字符。
⑥s格式：用来输出一个串。有几中用法
%s：例如:printf("%s", "CHINA")输出"CHINA"字符串（不包括双引号）。
%ms：输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部输出。若串长小于m，则左补空格。
%-ms：如果串长小于m，则在m列范围内，字符串向左靠，右补空格。
%m.ns：输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。
%-m.ns：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n>m，则自动取n值，即保证n个字符正常输出。
⑦f格式：用来输出实数（包括单、双精度），以小数形式输出。有以下几种用法：
%f：不指定宽度，整数部分全部输出并输出6位小数。
%m.nf：输出共占m列，其中有n位小数，如数值宽度小于m左端补空格。 
%-m.nf：输出共占n列，其中有n位小数，如数值宽度小于m右端补空格。
⑧e格式：以指数形式输出实数。可用以下形式：
%e：数字部分（又称尾数）输出6位小数，指数部分占5位或4位。
%m.ne和%-m.ne：m、n和”-”字符含义与前相同。此处n指数据的数字部分的小数位数，m表示整个输出数据所占的宽度。
⑨g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。
*关于printf函数的进一步说明：*
如果想输出字符"%",则应该在“格式控制”字符串中用连续两个%表示，如:
printf("%f%%", 1.0/3);
输出0.333333%。
对于单精度数，使用%f格式符输出时，仅前7位是有效数字，小数6位．
对于双精度数，使用%lf格式符输出时，前16位是有效数字，小数6位．
由高手指点
对于m.n的格式还可以用如下方法表示（例）
char ch[20];
printf("%*.*s\n",m,n,ch);

前边的*定义的是总的宽度，后边的定义的是输出的个数。分别对应外面的参数m和n 。我想这种方法的好处是可以在语句之外对参数m和n赋值，从而控制输出格式。 

今天()又看到一种输出格式 %n 可以将所输出字符串的长度值赋绐一个变量, 见下例:

int slen;

printf("hello world%n", &slen);

执行后变量被赋值为11

另外：

1、格式输出函数的一般形式

      函数原型： int printf(char * format[,argument,…]);
    
      函数功能：按规定格式向输出设备（一般为显示器）输出数据，并返回实际输出的字符数，若出错，则返回负数。
    
      它使用的一般形式为：
    
               printf("格式控制字符串",输出项列表);
    
      语句中“输出项列表”列出要输出的表达式（如常量、变量、运算符表达式、函数返回值等），它可以是0个、一个或多个，每个输出项之间用逗号（,）分隔。输出的数据可以是整数、实数、字符和字符串。
    
      "格式控制字符串"必须用英文的双引号括起来，它的作用是 控制输出项的格式和输出一些提示信息，例如
    
                    int i=97; printf("i=%d,%c\n",i,i);
    
                输出结果为：i=97,a
    
        语句“printf("i=%d,%c\n",i,i);”中的两个输出项都是变量i，但却以不同的格式输出，一个输出整型数97，另一个输出的却是字符a，其格式分别由“%d”与“%c”来控制。
    
        语句“printf("i=%d,%c\n",i,i);”的格式控制字符串中“i=”是普通字符，他将照原样输出；“%d”与“%c”是格式控制符；"\n"是转义字符，它的作用是换行。

2、格式控制

      格式控制由格式控制字符串实现。格式控制字符串由3部分组成：普通字符、转义字符、输出项格式说明。
    
      （1）普通字符。普通字符在输出时，按原样输出，主要用于输出提示信息。
    
      （2）转义字符。转义字符指明特定的操作，如"\n"表示换行，"\t"表示水平制表等。
    
      （3）格式说明部分由“%”和“格式字符串”组成，他表示按规定的格式输出数据。
    
        格式说明的形式为：
    
               %[flags][width][.prec][F|N|h|I][type]
    
        各部分说明如下：

“[]”表示该项为可选项，即可有可无，如 printf("%d",100);
flags为可选择的标志字符，常用的标志字符有：
 -   ——左对齐输出，默认为右对齐输出；
+   ——正数输出加号(+)，负数输出减号(-);
    空格 ——正数输出空格代替加号(+)，负数输出减号(-)。
    width为可选择的宽度指示符。
    用十进制正整数表示设置输出值得最少字符个数。不足则补空格，多出则按实际输出，默认按实际输出，例如：
    printf("%8d\n",100);       printf("%6d\n",100);       printf("%-8d\n",100);        printf("%+8\n",100);
    [.prec]为可选的精度指示符
    用“小数点”加“十进制正整数”表示，对“整数”、“实数”和“字符串”的输出有如下功能：对“整数”，表示至少要输出的数字个数，不足补数字0，多则原样输出；对“实数”，表示小数点后至多输出的数字个数，不足则补数字0，多则做舍入处理；对“字符串”，表示最多输出的字符个数，不足补空格，多则丢弃。
    例如：printf("%8.2f\n",3.14159);                     
    printf("%8.5f\n",3.14159);
    输出结果为：└┘└┘└┘└┘3.14                                
    └┘3.14159
    [F|N|h|I]为可选的输出长度修饰符，其功能如下：
    F ——输出远指针存放的地址；
    N——输出近指针存放的地址；
    h——输出短整型数据的值；
    l——输出长整型或双精度型数据的值。
    例如：long  n=40000;
            printf("%8ld\n",n);/*因为200*200是长整型数据*/
    type为可选的格式字符，用来进行格式转换。 
    #include<cstdio>
    int main()
    {
    //for int
    int i=30122121;
    long i2=309095024l;
    short i3=30;
    unsigned i4=2123453;
    printf("%d,%o,%x,%X,%ld,%hd,%u/n",i,i,i,i,i2,i3,i4);//如果是：%l,%h，则输不出结果 
    printf("%d,%ld/n",i,i2);//试验不出%ld和%d之间的差别，因为long是4bytes
    printf("%hd,%hd/n/n/n",i,i3);//试验了%hd和%d之间的差别，因为short是2bytes
    //for string and char
    char ch1='d';
    unsigned char ch2=160;
    char *str="Hello everyone!";
    printf("%c,%u,%s/n/n/n",ch1,ch2,str);//unsigned char超过128的没有字符对应
    
    //for float and double,unsigned and signed can not be used with double and float
    float fl=2.566545445F;//or 2.566545445f
    double dl=265.5651445;
    long double dl2=2.5654441454;
    //%g没有e格式，默认6位包括小数点前面的数,
    //%f没有e格式，默认6位仅只小数点后面包含6位
    //%e采用e格式，默认6位为转化后的小数点后面的6位
    printf("%f,%e,%g,%.7f/n",fl,dl,dl,dl);
    printf("%f,%E,%G,%f/n",fl,dl,dl,dl);//%F is wrong
    printf("%.8f,%.10e/n",fl,dl);
    printf("%.8e,%.10f/n/n/n",fl,dl);
    //for point 
    int *iP=&i;
    char *iP1=new char;
    void *iP2;//dangerous!
    printf("%p,%p,%p/n/n/n",iP,iP1,iP2);
    
    //其他知识：负号，表示左对齐（默认是右对齐）；%6.3，6表示宽度，3表示精度
    char *s="Hello world!";
    printf(":%s: /n:%10s: /n:%.10s: /n:%-10s: /n:%.15s: /n:%-15s: /n:%15.10s: /n:%-15.10s:/n/n/n",
    s,s,s,s,s,s,s,s);
    double ddd=563.908556444;
    printf(":%g: /n:%10g: /n:%.10g: /n:%-10g: /n:%.15g: /n:%-15g: /n:%15.10g: /n:%-15.10g:/n/n/n",
    ddd,ddd,ddd,ddd,ddd,ddd,ddd,ddd);
    //还有一个特殊的格式%*.* ,这两个星号的值分别由第二个和第三个参数的值指定
    printf("%.*s /n", 8, "abcdefgggggg");
    printf("%*.*f /n", 3,3, 1.25456f);
    
    return 0;

    ### 删除字符串的元素
    
    all空格:
    
    void trim(string &s)
    {
    	int index = 0;
    	if(!s.empty())
    	{
    		while( (index = s.find(' ',index)) != string::npos)
    		{
    			s.erase(index,1);
    		}
    	}
    }
    
    首尾空格：
    
    std::string& trim(std::string &s) 
    {
        if (!s.empty()) 
        {
            s.erase(0,s.find_first_not_of(" "));
        	s.erase(s.find_last_not_of(" ") + 1);
        }
        return s;
    }

其他：

string str;

string target;

int pos = str.find(target);

然后通过erase进行删除：

n = target.size();

str = str.erase(pos,n);           //从pos这个位置开始，删除n个字符

### swap

交换指针所在地址

swap的一些特化：

std::string, std::vector各自实现了swap函数，

1.template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void __CLRCALL_OR_CDECL swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// swap _Left and _Right strings
	_Left.swap(_Right);
	}
	void __CLR_OR_THIS_CALL swap(_Myt& _Right)
		{	// exchange contents with _Right
		if (this == &_Right)
			;	// same object, do nothing
		else if (_Mybase::_Alval == _Right._Alval)
			{	// same allocator, swap control information
 #if _HAS_ITERATOR_DEBUGGING
			this->_Swap_all(_Right);
 #endif /* _HAS_ITERATOR_DEBUGGING */
			_Bxty _Tbx = _Bx;
			_Bx = _Right._Bx, _Right._Bx = _Tbx;
			size_type _Tlen = _Mysize;
			_Mysize = _Right._Mysize, _Right._Mysize = _Tlen;
			size_type _Tres = _Myres;
			_Myres = _Right._Myres, _Right._Myres = _Tres;
			}
		else
			{	// different allocator, do multiple assigns
			_Myt _Tmp = *this;
			*this = _Right;
			_Right = _Tmp;
			}
		}

2.template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
	{	// swap _Left and _Right vectors
	_Left.swap(_Right);
	}
	void swap(_Myt& _Right)
		{	// exchange contents with _Right
		if (this == &_Right)
			;	// same object, do nothing
		else if (this->_Alval == _Right._Alval)
			{	// same allocator, swap control information
 #if _HAS_ITERATOR_DEBUGGING
			this->_Swap_all(_Right);
 #endif /* _HAS_ITERATOR_DEBUGGING */
			this->_Swap_aux(_Right);
			_STD swap(_Myfirst, _Right._Myfirst);
			_STD swap(_Mylast, _Right._Mylast);
			_STD swap(_Myend, _Right._Myend);
			}
		else
			{	// different allocator, do multiple assigns
			this->_Swap_aux(_Right);
			_Myt _Ts = *this;
			*this = _Right;
			_Right = _Ts;
			}
		}

swap(Right)进行判断，如果使用了相同的分配器，则直接交换控制信息，否则调用string::operator=进行拷贝赋值。。。所以建议优先使用swap函数，而不是赋值操作符。

vector的swap原理跟string完全一致，只有当使用了不同分配器才进行字节拷贝。其余情况直接交换控制信息。

5，Copy and  Swap idiom

目的：C++异常有三个级别：基本，强，没有异常。通过创建临时对象然后交换，能够实现重载赋值操作符的强异常安全的执行。

Loki中智能指针 临时变量跟this交换，临时变量自动销毁~

        SmartPtr& operator=(SmartPtr<T1, OP1, CP1, KP1, SP1, CNP1 >& rhs)
        {
            SmartPtr temp(rhs);
            temp.Swap(*this);
            return *this;
        }

boost::share_ptr，share_ptr定义了自己的swap函数。

    shared_ptr & operator=( shared_ptr const & r ) // never throws
    {
        this_type(r).swap(*this);
        return *this;
    }
    void swap(shared_ptr<T> & other) // never throws
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

下面说说String::opreator=函数的优化：

最一般的写法，特点：使用const string& 传参防止临时对象。

 String& String::operator =(const String & rhs)
{
	if (itsString)
		delete [] itsString;
	itsLen = rhs.GetLen();
	itsString = new char[itsLen+1];
	for (unsigned short i = 0;i<itsLen;i++)
		itsString[i] = rhs[i];
	itsString[itsLen] = '/0';
	return *this;
}

优化1，防止自我间接赋值，a = b; c = b; a = c; 如果没有第一个if判断，当把c赋给a的时候，删除了a.itsString，后面的拷贝就会出错。注意是if(this==&rhs), 而不是if(*this==rhs) .

 String& String::operator =(const String & rhs)
{
	if (this == &rhs)
		return *this;
	if (itsString)
		delete [] itsString;
	itsLen=rhs.GetLen();
	itsString = new char[itsLen+1];
	for (unsigned short i = 0;i<itsLen;i++)
		itsString[i] = rhs[i];
	itsString[itsLen] = '/0';
	return *this;
}

优化2，不进行拷贝赋值，只是交换控制信息，而且是强异常安全：

 String & String::operator = (String const &rhs)
{
	if (this != &rhs)
		String(rhs).swap (*this); // Copy-constructor and non-throwing swap
	// Old resources are released with the destruction of the temporary above
	return *this;
}

优化3，以最原始的传值方式传参，避免临时对象创建：

 String & operator = (String s) // the pass-by-value parameter serves as a temporary
{
   s.swap (*this); // Non-throwing swap
   return *this;
}// Old resources released when destructor of s is called.

最后这张方式主要是对C++新特性rvalue的优化，具体参见：http://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap 

 6. vector clear and swap trick

vector.clear并只是将size变量置为0，并没有及时归还OS，STL仍然持有内存，以便后续push_back。
————————————————
版权声明：本文为CSDN博主「ryfdizuo」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ryfdizuo/article/details/6435847

### 进制转换

一.指定格式输出

1.C中指定格式输出

printf("%05o\n",35);    //按八进制格式输出，保留5位高位补零
printf("%03d\n",35);    //按十进制格式输出，保留3位高位补零
printf("%05x\n",35);    //按十六进制格式输出，保留5位高位补零
 2.C++中指定格式输出

复制代码
#include <bitset>  
#include<iostream>
using namespace std;  
int main()  
{  
    cout << "35的8进制:" << std::oct << 35<< endl;  
    cout << "35的10进制" << std::dec << 35 << endl;  
    cout << "35的16进制:" << std::hex << 35 << endl;  
    cout << "35的2进制: " << bitset<8>(35) << endl;      //<8>：表示保留8位输出
    return 0;  }  
复制代码
二.C/C++各种进制转换库函数

1.任意2~36进制数转化为10进制

自己实现函数

复制代码
int Atoint(string s,int radix)    //s是给定的radix进制字符串
{
    int ans=0;
    for(int i=0;i<s.size();i++)
    {
        char t=s[i];
        if(t>='0'&&t<='9') ans=ans*radix+t-'0';
        else ans=ans*radix+t-'a'+10;
    }
        return ans;
}
复制代码
strol()函数：

函数原型：long int strtol(const char *nptr, char **endptr, int base)

格式：base是要转化的数的进制，非法字符会赋值给endptr，nptr是要转化的字符，

例如：

复制代码
`#include<stdio.h>
int main()  
{  
    char a[20]="10549stend#12";  
    char *stop;  
    int ans=strtol(a, &stop, 8);   //将八进制数1054转成十进制，后面均为非法字符
    printf("%d\n",ans);  
    printf("%s\n", stop);   
    return 0;
}`
//输出556
复制代码
*注意：

1）如果base为0，且字符串不是以0x(或者0X)开头，则按十进制进行转化。

2）如果base为0或者16，并且字符串以0x（或者0X）开头，那么，x（或者X）被忽略，字符串按16进制转化。

3）如果base不等于0和16，并且字符串以0x(或者0X)开头，那么x被视为非法字符。

4）对于nptr指向的字符串，其开头和结尾处的空格被忽视，字符串中间的空格被视为非法字符 。

2.将10进制数转换为任意的n进制数，结果为char型。

自己实现函数

复制代码
`string intToA(int n,int radix)    //n是待转数字，radix是指定的进制
{
    string ans="";
    do{
        int t=n%radix;
        if(t>=0&&t<=9)    ans+=t+'0';
        else ans+=t-10+'a';
        n/=radix;
    }while(n!=0);    //使用do{}while（）以防止输入为0的情况
    reverse(ans.begin(),ans.end());
    return ans;    
}`
复制代码
1）itoa（）函数（可以将一个10进制数转换为任意的2-36进制字符串）:

函数原型：char*itoa(int value,char*string,int radix);

格式：itoa(num, str, 2); num是一个int型的，是要转化的10进制数，str是转化结果，后面的值为目标进制。

复制代码
#include<stdio.h> 
#include<stdlib.h> 
int main()  
{  
    int num = 10;  
    char str[100];  
    _itoa(num, str, 2);  //c++中一般用_itoa，用itoa也行,
    printf("%s\n", str);  
    return 0;  
}
复制代码
2）sprintf()函数（可以将一个10进制数转换为指定格式的n进制字符串）

函数原型：int sprintf( char *buffer, const char *format, [ argument] … )

复制代码
#include<stdio.h>  
int main()  
{  
    char s[100]={0};
    sprintf(s, "%d", 123); //十进制输出产生"123"
    sprintf(s, "%4d%4d", 123, 4567); //指定宽度不足的左边补空格，产生：" 1234567"
    sprintf(s, "%8o", 123);    //八进制输出，宽度占8个位置
    sprintf(s, "%8x", 4567); //小写16 进制，宽度占8 个位置，右对齐
    sprintf(s, "%10.3f", 3.1415626); //产生：" 3.142"
    int i = 100;
    sprintf(s, "%.2f", i);    //注意这是不对的
    sprintf(s, "%.2f", (double)i);    //要按照这种方式才行
    return 0;  
}  
复制代码
三.使用字符串流string，stream

1）8,16->10

复制代码
#include<iostream>
#include<string>
#include<sstream>
using namespace std;
int main(void)
{
    string s="20";
    int a;
    stringstream ss;
    ss<<hex<<s;    //以16进制读入流中
    ss>>a;        //10进制int型输出
    cout<<a<<endl;
        return 0;
}
//输出：32
复制代码
2)10->8,16

复制代码
#include<cstdio>
#include<iostream>
#include<string>
#include<sstream>
using namespace std;
int main(void)
{
    string s1,s2;
    int a=30;
    stringstream ss;
    ss<<oct<<a;        //10进制转成八进制读入流中，再以字符串输出
    ss>>s1;            
    cout<<s1<<endl;        //输出：36
    ss.clear();        //不清空可能会出错。
    ss<<hex<<a;         //10进制转成十六进制读入流中，，再以字符串输出
    ss>>s2;            
    cout<<s2<<endl;        //输出：1e
    return 0;
}

### 回文数

#### string

```c++
bool hw(string a) { //判断回文
	string s = a; //把 a 赋值给 s
	reverse(s.begin(), s.end()); //反转字符串 s
	return s == a; //判断 a 和 s 是否相等
}
```



```c++
bool vs(string a){
int i,length,flag=1;
    length=strlen(a);
    for(i=0;i<=length/2;i++) {
       if(a[i]!=a[length-i-1]) {
           flag=0;
           break;
       }
    }
    if(flag==1)return 1;
else return 0;  

}

```

#### stack

```c++
typedef struct
{
    char data[StackSize];//开栈为100;
    int top=0;
}SeqStack;
  bool vs(  SeqStack s,,string str){
    int len=strlen(str);
    int i,flag=1;
    for(i=0;i<len/2;i++)//将一半字符入栈
        s.data[s.top++]=str[i];
    if(len%2) i++; //奇数时自动跳过中间的数字,如121,跳过2,比较1
    while(s.top)//相当于EmptyStack(&s),判断是否栈空.
    {// 每弹出一个字符与相应字符比较
        char temp=s.data[--s.top];
        if(temp!=str[i]) flag=0;
        else i++;
    }
    if(flag==0)return 0;
      else return 1;
}

```

 




## 字符串

### 字符串查找

 find()  和  rfind() 函数:  find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。
str.find(str2)，当str2是str的子串时，返回其在str中第一次出现的位置，否则返回string::npos。

str.find(str2,pos)，是从str的pos号位开始查找匹配str2，找到返回其位置；否则返回string::npos。

string::npos是一个常数，其本身的值等于-1，但由于是unsigned int类型，因此，也可以认为是unsigned int类型的最大值（4294967295）。

rfind()与find()很相似，差别在于查找顺序不一样，find()是从指定位置起向后查找，直到串尾。rfind()是从指定位置起向前查找，直到串首，相当于逆向查找，返回的位置仍然是从前往后数的。

返回值类型	函数	描述
int	str.find(char c, int pos = 0);	从pos开始查找字符c在C++字符串str中的位置
int	str.find(const char *s, int pos = 0); 	从pos开始查找c语言字符串s在C++字符串str中的位置
int	str.find(const char *s, int pos, int n);	从pos开始查找c语言字符串s中前n个字符在C++字符串str中的位置
int	str.find(const string &s, int pos = 0); 	从pos开始查找c++字符串s在C++字符串str中的位置。
int	str.rfind(char c, int pos = npos);	从pos开始从后向前查找字符c在C++字符串str中的位置
int	str.rfind(const char *s, int pos = npos);  	从pos开始从后向前查找c语言字符串s在C++字符串str中的位置
int	str.rfind(const char *s, int pos, int n = npos);	从pos开始从后向前查找c语言字符串s中前n个字符在C++字符串str中的位置
int	str.rfind(const string &s,int pos = npos);	从pos开始从后向前查找c++字符串s在C++字符串str中的位置。
2、find_first_of（）和 find_first_not_of（）和 函数: 
        在源串中从位置pos起往后查找，只要在源串中遇到一个字符，该字符与目标串中任意一个字符相同，就停止查找，返回该字符在源串中的位置；若匹配失败，返回npos。
        注意find_first_of函数和find函数的区别，如果是str.find(“abc”)的话，则必须找到完全匹配abc的才算查找成功，而find_first_of只需要abc中任何一个出现即可。

返回值类型	函数	描述
int	str.find_first_of(char c, int pos = 0);	从pos开始查找字符c在C++字符串str中的位置
int	str.find_first_of(const char *s, int pos = 0); 	从pos开始查找c语言字符串s中任何一个字符首次在C++字符串str中的位置
int	str.find_first_of(const char *s, int pos, int n);	从pos开始查找c语言字符串s中前n个字符中任何一个字符首次在C++字符串str中的位置
int	str.find_first_of(const string &s,int pos = 0); 	从pos开始查找c++字符串s中任何一个字符首次在C++字符串str中的位置。
int	str.find_first_not_of(char c, int pos = 0);	从pos开始查找字符c以外的任何一个字符在C++字符串str中的位置
int	str.find_first_not_of(const char *s, int pos = 0);  	从pos开始c语言字符串s以外的任何一个字符在C++字符串str中的位置
int	str.find_first_not_of(const char *s, int pos,int n);	从pos开始查找c语言字符串s中前n个字符以外的任何一个字符在C++字符串str中的位置
int	str.find_first_not_of(const string &s,int pos = 0);	从pos开始查找c++字符串s以外的任何一个字符在C++字符串str中的位置。
8.3、find_last_of（）和 find_last_not_of（）和 函数: 
在源串中从位置pos起往前查找，只要在源串中遇到一个字符，该字符与目标串中任意一个字符相同，就停止查找，返回该字符在源串中的位置；若匹配失败，返回npos。find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找

返回值类型	函数	描述
int	str.find_last_of(char c, pos = npos);	从pos开始由后向前查找字符c在C++字符串str中的位置
int	str.find_last_of(const char *s, int pos = npos); 	从pos开始由后向前查找c语言字符串s中任何一个字符首次在C++字符串str中的位置
int	str.find_last_of(const char *s, int pos, int n=npos);	从pos开始由后向前查找c语言字符串s中前n个字符中任何一个字符首次在C++字符串str中的位置
int	str.find_last_of(const string &s,int pos = npos); 	从pos开始由后向前查找c++字符串s中任何一个字符首次在C++字符串str中的位置。
int	str.find_last_not_of(char c, int pos = npos);	从pos开始由后向前从后向前查找字符c以外的任何一个字符在C++字符串str中的位置
int	str.find_last_not_of(const char *s, int pos = npos);  	从pos开始由后向前从后向前查找c语言字符串s以外的任何一个字符在C++字符串str中的位置
int	str.find_last_not_of(const char *s, int pos,int n);	从pos开始由后向前从后向前查找c语言字符串s中前n个字符以外的任何一个字符在C++字符串str中的位置
int	str.find_last_not_of(const string &s,int pos = npos);	从pos开始由后向前从后向前查找c++字符串s以外的任何一个字符在C++字符串str中的位置。

### 特定位置取长度

string的子串substr():

这个函数的作用是取字符串str中位置为pos开始的len个字符，返回一个字符串。

如果pos开始后len个字符长度超出了字符串的长度，则取到最后一个字符。

返回值类型	函数	描述
string	str.substr(int pos = 0,int n = npos) ;	返回pos开始的n个字符组成的字符串给str字符串

### 字符串清除

把字符串清空
把字符串清空的方法有三个：

1、s=””;

２、s.clear();

３、s.erase();

**删除**

返回值类型	函数	描述
iterator	str.erase(iterator first, iterator last);	删除[first，last）之间的所有字符，返回删除后迭代器的位置
iterator	str.erase(iterator it);	删除it指向的字符，返回删除后迭代器的位置
string	str.erase(int pos = 0, int n = npos);	删除pos开始的n个字符，返回修改后的字符串

### 字符串插入

string类的插入函数：插入字符串insert()。
返回值类型	函数	描述
string	str.insert(int p0, const char *s);	在p0位置插入C语言字符串s
string	str.insert(int p0, const char *s, int n);	在p0位置插入C语言字符串s的前n个字符
string	str.insert(int p0,const string &s);	在p0位置插入C++字符串s
string	str.insert(int p0,const string &s, int pos, int n);	在p0位置插入C++字符串s从pos开始的连续n个字符
string	str.insert(int p0, int n, char c);	在p0处插入n个字符c
iterator	str.insert(iterator it, char c);	在it处插入字符c，返回插入后迭代器的位置
void	str.insert(iterator it, const_iterator first, const_iteratorlast);	在it处插入从first开始至last-1的所有字符
void	str.insert(iterator it, int n, char c);	在it处插入n个字符c

### string赋值函数：

给字符串赋值assign()函数。
返回值类型	函数	描述
string	str=(const string &s);	把字符串s，赋值给字符串str
string	str.assign(const char *s);	用c类型字符串s赋值给字符串str
string	str.assign(const char *s,int n);	用c字符串s前n个字符，赋值给字符串str
string	str.assign(const string &s);	把字符串s，赋值给字符串str
string	str.assign(int n,char c);	用n个字符c，赋值给字符串str
string	str.assign(const string &s,int start,int n);	把字符串s中从start开始的n个字符，赋值给字符串str
string	str.assign(const_iterator first,const_itertor last);	把first和last迭代器之间的部分，赋值给字符串str


### 字符的连接（在尾巴上增加）

​        1、append()函数可以用来在字符串的末尾追加字符和字符串，

        2、也可以用　+　和　+=　来实现，
    
        3、push_back()在字符串的末尾追加一个字符，不能追加字符串。

返回值类型	函数	描述
string	str+=(const string &s);	把字符串s,连接到字符串str的结尾 
string	str.append(const char *s); 	把c类型字符串s,连接到字符串str的结尾 
string	str.append(const char *s,int n);	把c类型字符串s的前n个字符,连接到字符串str的结尾 
string	str.append(const string &s); 	把字符串s,连接到字符串str的结尾 ,同+=相同。
string	str.append(const string &s,int pos,int n);	把字符串s中从pos开始的n个字符,连接到字符串str的结尾 
string	str.append(int n,char c);  	在字符串str结尾添加n个字符c
string	str.append(const_iterator first,const_iterator last);	把迭代器first和last之间的部分,连接到字符串str的结尾 
string	str.push_back(char c)	在字符串str的末尾追加一个字符

### 替换函数（replace）：替换字符串。

返回值类型	函数	描述
string	str.replace(int p0, int n,const char *s);	删除从p0开始的n0个字符，然后在p0处插入串s
string	str.replace(int p0, int n0,const char *s, int n);	删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符
string	str.replace(int p0, int n0,const string &s);	删除从p0开始的n0个字符，然后在p0处插入串s
string	str.replace(int p0, int n0,const string &s, int pos, int n);	删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符
string	str.replace(int p0, int n0,int n, char c);	删除p0开始的n0个字符，然后在p0处插入n个字符c
string	str.replace(iterator first0, iterator last0,const char *s);	把[first0，last0）之间的部分替换为字符串s
string	str.replace(iterator first0, iterator last0,const char *s, int n);	把[first0，last0）之间的部分替换为s的前n个字符
string	str.replace(iterator first0, iterator last0,const string &s);	把[first0，last0）之间的部分替换为串s
string	replace(iterator first0, iterator last0,int n, char c);	把[first0，last0）之间的部分替换为n个字符c
string	replace(iterator first0, iterator last0,const_iterator first, const_iterator last);	把[first0，last0）之间的部分替换成[first，last）之间的字符串

### 字符串的输入输出。>>、 << 、getline()

1、string类重载运算符operator>>用于输入，同样重载运算符operator<<用于输出操作。

2、getline()的原型： getline ( istream &is , string &str , char delim );

其中:

istream &is 表示一个输入流，譬如cin；

string&str表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；

char delim表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为'\n'，也就是回车换行符（遇到回车停止读入）。

例如：

string line;
cout<<"please cin a line:";
getline（cin,line,'#');
cout<<"The line you give is:"<<line<<endl;
输入"You are the #best!" 的时候，输入流实际上只读入了"You are the "，#后面的并没有存放到line中。

程序运行结果应该是这样的： 

please cin a line:You are the #best!
The line you give is:You are the 
while(getline(cin,line))语句

注意这里默认回车符停止读入,按Ctrl+Z或键入回车即可退出循环。

在这个语句中，首先getline从标准输入设备上读入字符，然后返回给输入流cin，注意了，是cin，所以while判断语句的真实判断对象是cin，也就是判断当前是否存在有效的输入流。在这种情况下，我想只要你的电脑不中毒不发神经你的输入流怎么会没有效？所以这种情况下不管你怎么输入都跳不出循环，因为你的输入流有效，跳不出循环。

然而有些同学误以为while判断语句的判断对象是line（也就是line是否为空），然后想通过直接回车（即输入一个空的line）跳出循环，却发现怎么也跳不出循环。这是因为你的回车只会终止getline()函数的读入操作。getline()函数终止后又进行while（）判断（即判断输入流是否有效，你的输入流当然有效，满足条件），所以又运行getline()函数。

所以，以下的写法根本不可能让你推出while（）循环的：

while(getline(cin,line))    cout<<line<<endl;
二、cin.getline()

此函数会一次读取多个字符(包括空白字符）。它以指定的地址为存放第一个读取的字符的位置，依次向后存放读取的字符，直到读满N-1个，或者遇到指定的结束符为止。若不指定结束符，则默认结束符为'\n'。其语法为:

cin.getline(字符指针(char*),字符个数N(int),结束符(char));

#include <bits/stdc++.h>
using namespace std;
int main()
{char a[30];
 cout << "请输入一个字符串：" << endl;
 cin.getline(a, 10);//第10位存放字符串结束符'\0'
 for (int i = 0; i<10; i++)
 cout << "第"<<i+1<<"个值为："<<a[i] << endl;
 return 0;
}

## 2022寒假牛客算法入门比赛

[^]: 思维：括题目做法的灵感难 度、思考难度、思考深度等方面；知识:出该题目所需知识的要求，包括但不限于题目对算法；实现：实现该题算法的代码难度，包括对实现技巧的要求、对



好多题都没有思路 仿佛脑子停滞了。其实很多题抛开思维就是经验之谈了，发现着手点，然后很轻松找到知识点（前提是思维是正确的），最后就是板子+变形。赛后看别人的代码，模拟代码运行很容易就知道码题人的思路了（证明对方很强，写代码别人很轻松能读懂，一对比发现自己蒟蒻欸）。

### 第一场

难度 💡💡💡💡💡

完成度🎈🎈🎈:

一道动态计算最大距离，一个for+max（）解决

两道数学题，推公式

有一个牛牛看云：Σ*i*=1*n*Σ*j*=*i**n*∣*a**i*+*a**j*−1000∣

这个硬开for会爆时间；究其本质，一串数中会相加的数就是各两两相加，所以用排列组合的知识就可以解决

`for(int i=1;i<=n;i++)
	{
		int tem=0;
		cin>>tem;
		a[tem]++;
	}
	for(int i=0;i<=1000;i++){
		for(int j=i;j<=1000;j++){
			if(i==j)ans=ans+abs(i+j-1000)*(a[i]*(a[j]-1)/2+a[i]);
			else{
				ans=ans+abs(i+j-1000)*a[i]*a[j];
			} 
		}
	}`

### 第二场

难度：💡💡💡💡

AC:🎈🎈

一道模拟：

`#include<iostream>
using namespace std;
int cnt[10];
int main(){
    string s;cin>>s;
    for(char ch=s[i],int i=0;i<s.size()；i++)`

`if(ch!='5')cnt[ch-'0']++,cnt[5]++;//
    for(int i=1;i<=9;i++)cout<<cnt[i]<<" ";
}`

一道贪心+模拟

`#include<iostream>
using namespace std;
int main(){
    long long x,a,b;cin>>x>>a>>b;
    string s;cin>>s;
    int len=0;
    for(char ch:s)
        if(ch=='1'&&x>=a)len++,x-=a;
        else x+=b;
    cout<<len;
}`

`以后不要自作多情，考虑什么体力不够,要不要不接球...`

尬住的原因是：理解题意捏，不操作就能加

### 第三场

难度：💡💡💡💡

AC:🎈🎈

hello world ＆01串，要求字符不同---有一个不同就行

其他：

.1.模拟：

这6个条件可以拆开分别考虑。 

 同时这6个条件在固定所选子串的其中一个端点后，另一个端点的合法性是单调的。 

 所以可以使用二分或者尺取的方式直接判断每一个条件的合法区间。 

 最后取一个合法区间的并集即可。

2.欧拉回路

3.位运算

4.二分或结论

5.桶，并查集，逆元

### 第四场

难度：💡

AC:🎈🎈🎈🎈🎈

1.f*(*x)=1

或者f(⌊x/2⌋)+f(⌈x/2⌉)x=1  x*≥2

这是原数返回

2.由于输出是浮点数，所以可以用pow函数。一般整数的乘方不建议用pow函数（容易出现精度问题），建议用for循环或者快速幂进行模拟。

3.本题要求构造一个数yyy，为给定的数xxx的倍数，并且二进制下包含xxx的子串，并且 yyy 中'1'的数量和 xxx 中 '1'的数量不能相等。

如果没有最后一个条件，输出 2x 2x2x 即可。因为 2x2x2x 是 xxx 的二进制后面添加一个 '0'，显然满足前两个条件。

现在有了 '1' 数量不等的限制条件，那么就不能用上面的方式构造。

一个最简单的构造方式就是，将 xxx 的二进制重复写两次。显然满足子串条件和'1'不等条件。倍数条件也很容易证明：将 xxx 的二进制写两次等价于将 xxx 后面添加一些'0'，再加上 xxx。而第一步操作也就是乘上一个2的幂，显然一直都满足是xxx的倍数这一条件。

#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    ll x;
    cin>>x;
    int i;
    for(i=0;i<=32;i++)if(1LL<<i>x)break;
    cout<<x*(1LL<<i)+x;

}

4.读题啊啊啊

'<' 代表降八度，'>'代表升八度。那么用一个变量统计当前八度的情况，然后对应哪个音直接输出即可，后面根据八度的情况来添加对应数量的'.'或者'*'即可。

#include<bits/stdc++.h>
using namespace std;
int main(){
    int cnt=0,i;
    string s;
    cin>>s;
    for(i=0;i<s.length();i++){
        if (s[i]=='>')cnt++;
        else if(s[i]=='<')cnt--;
        else{
            if(s[i]=='C')cout<<1;
            if(s[i]=='D')cout<<2;
            if(s[i]=='E')cout<<3;
            if(s[i]=='F')cout<<4;
            if(s[i]=='G')cout<<5;
            if(s[i]=='A')cout<<6;
            if(s[i]=='B')cout<<7;
            if(cnt>0)for(int j=0;j<cnt;j++)cout<<'*';
            else for(int j=cnt;j<0;j++)cout<<'.';
        }//不清零最妙了，保存了影响
    }
    cout << endl;
}

5.差分介绍：

一个数组，有多次操作，每次对某个区间 [l,r][l,r][l,r] 上每个数加上 xxx，问最终的数组是什么样子。

我们不妨假设初始的数组全是0。当我们对 [l,r][l,r][l,r] 区间上每个数加上 xxx 以后，这个数组就变成了 0,0,...,0,x,x,...,x,0,0,0

如果我们只对两个位置的数进行操作：a[l]+=x,a[r+1]−=xa[l]+=x,a[r+1]-=xa[l]+=x,a[r+1]−=x，当我们做一次前缀和以后，我们发现，这个数组就变成了我们想要的样子。（前缀和是指，对于新数组 sumsumsum，sum[i]sum[i]sum[i] 代表a数组中前i项之和。sumsumsum 数组可以通过 sum[i]=sum[i−1]+a[i]sum[i]=sum[i-1]+a[i]sum[i]=sum[i−1]+a[i] 得出）。

因此我们可以先对每个区间修改只修改两个数：a[l]+=x,a[r+1]−=xa[l]+=x,a[r+1]-=xa[l]+=x,a[r+1]−=x，在最后做一次前缀和就可以了。这就是差分的基本思想。

进阶：如果这道题，t*t* 和 a_i*a**i* 的数据范围是 10^9109 怎么做？（提示：离散化）

6.本题要求一个固定的点到一条折线的最短距离。由于折线可以看成是很多条线段，所以可以规约成点到线段的最短距离。

（虽然这个是板子，但不建议直接去[百度]()，毕竟赛场上没有[百度]()）

显然，最终的答案一定为以下两种情况的一种：点到直线的最短距离、或点到线段某个端点的最短距离。

什么时候会遇到第二种情况呢？当且仅当点到直线的最短距离所对应的那个点不在线段上。

所以这道题一个最笨的方法就是：先根据线段求出直线两点式，然后求斜率乘积为-1（这样才能垂直）的直线，求出点斜式（还要特判斜率不存在的情况），这样求出两个直线交点，判断交点在不在线段上。如果在的话直接输出初始点到交点距离，否则输出初始点到线段两个端点的最小那个距离。

如果这道题用这种方法来做，计算量将非常大，题目难度也直接飙上1700+。事实上，本题有更简单的做法：

首先如何判断最终能不能取到点到直线距离呢？很简单，把点 PPP 和线段两个端点 AAA 和 BBB ，这三个点连接成一个三角形，判断该三角形的角 AAA 和角 BBB 是否是钝角即可。判断钝角可以直接用勾股定理：a2+b2<c2a^2+b^2<c^2a2+b2<c2 则角 CCC 为钝角。

然后如何求点到直线的距离呢？也很简单，PPP到直线ABABAB 的距离即三角形 PABPABPAB 中ABABAB边上的高。直接用 2∗SABC/AB2*S_{ABC}/AB2∗SABC/AB即可。而三角形面积可以直接用海伦公式：S=p∗(p−a)∗(p−b)∗(p−c),p=(a+b+c)/2S=\sqrt{p*(p-a)*(p-b)*(p-c)},p=(a+b+c)/2S=p∗(p−a)∗(p−b)∗(p−c),p=(a+b+c)/2。

可以发现，换一个做法，原本计算量巨大的题目将极大的减少做题的负担。在赛场上如果发现某题计算量非常大，不妨洗个脸冷静一下，换一个思路可能会豁然开朗。

*请注意，本题如果直接用网上的long long 存点的板子，可能会导致答案错误。因为在计算过程中会出现超过10^9的情况，这样在计算勾股定理的时候再一个平方就会出现爆long long精度的问题。解决办法要么使用__int128或者高精度，要么直接用double存点。 

7.欧拉降幂

一个长度为 nnn 的数组，显然有 2n−12^n-12n−1 个非空子序列。如果我们去枚举每个子序列然后求其权值，复杂度将到达恐怖的 O(n∗2n)O(n*2^n)O(n∗2n)，显然会超时。

我们可以观察到，当[排序]()了以后，如果确定了最大值和最小值，它们中间的数取不取对结果是没有影响的。因此，通过这种方式可以枚举最大值和最小值，中间的部分规约在一起，利用欧拉降幂进行计算，这样复杂度为 O(n2logn)O(n^2logn)O(n2logn)，这样还是不够。

我们看看这些指定了最大值和最小值的区间有什么特点呢？如果区间长度 (r−l+1)(r-l+1)(r−l+1) 为 kkk ，那么中间的数有【取】或【不取】两种状态，因此有 2k−22^{k-2}2k−2 的权值贡献。对于长度固定的情况，那么贡献的次数也就固定了。因此这部分可以利用乘法分配律合并起来。

这样我们最终只需要枚举区间长度就可以了。

举个例子，对于数组 [1,3,5,5,6] 而言（不妨设已经排好序了）。

我们枚举长度 2，最终带来的权值收益是 

(1∗3)20∗(3∗5)20∗(5∗5)20∗(5∗6)20(1*3)^{2^0}*(3*5)^{2^0}*(5*5)^{2^0}*(5*6)^{2^0}(1∗3)20∗(3∗5)20∗(5∗5)20∗(5∗6)20

我们枚举长度 3，最终带来的权值收益是 

(1∗5)21∗(3∗5)21∗(5∗6)21(1*5)^{2^1}*(3*5)^{2^1}*(5*6)^{2^1}(1∗5)21∗(3∗5)21∗(5∗6)21

我们枚举长度 4，最终带来的权值收益是 (1∗5)22∗(3∗6)22(1*5)^{2^2}*(3*6)^{2^2}(1∗5)22∗(3∗6)22

我们枚举长度 5，最终带来的权值收益是 (1∗6)23(1*6)^{2^3}(1∗6)23

根据公式 at∗bt=(a∗b)ta^t*b^t=(a*b)^tat∗bt=(a∗b)t，这些幂相同的底数都是可以合并的。合并之后我们发现，让枚举的长度变大的时候，它们的乘积是可以 O(logn)O(logn)O(logn)进行维护的，因为只除掉了两个数。这部分可以用逆元解决。（如果枚举的长度从大到小，甚至不需要逆元）

那么最终的问题就是怎么解决计算 x2yx^{2^y}x2y了。这就是这里要介绍的欧拉降幂：

根据费马小定理，当 aaa 和 ppp 互素时，有ap−1%p=1a^{p-1}\%p=1ap−1%p=1。

那么我们要计算aba^bab 模 ppp 的值，可以先把 bbb 写成 b=(p−1)u+vb=(p-1)u+vb=(p−1)u+v 的形式，即求 a(p−1)u+v=a(p−1)u∗ava^{(p-1)u+v}=a^{(p-1)u}*a^va(p−1)u+v=a(p−1)u∗av，前部分模 ppp为1，所以答案就是 ava^vav。v是什么？正是 bbb 对 p−1p-1p−1 取模的值。

也就是说，我们要求 ab%pa^b\%pab%p，如果 bbb 是个比较大的数（可能是个幂的形式），可以先让 bbb 对 (p−1)(p-1)(p−1) 取模，是不影响最终答案的正确性的（前提是 aaa 和 ppp 互素）。这个取模就叫做欧拉降幂。

## 高精度

### 数组

**重点：
高精度数的读入与输出
高精度数的加减乘除
进一步熟悉函数的使用（模块化编程的思想）
难点：
高精度数的除法
高精度计算的优化
为什么要用到高精度计算？
int
long long
double
等进行计算的精度只有十几位，如果要进行数十、百、千、万位的数的计算就要用到高精度计算**

*高精度计算的基本方法*
用字符串来读入数据
将字符串转为整数数组，该数组的每一个元素对应一位十进制数，下标顺序指明每一位的序号（为了计算对位的方便，一般会进行倒序存储），一般还用其下标0来存储该数的位数，如a[0]，也是为了方便计算和输出等。
然后对每一位进行计算，运算规则如同算术运算。
输出的时候一般也是倒序（因为存储的时候是倒序的）。

##### 高精度加法

首先观察我们在竖式加法时的做法
str1=“3216”
str2=“999765”

     3216
 + 999765
---------
  1002981

对位（将str1的各位6和str2的各位5对齐，倒序存储就是为了对位和计算的方便）
从最低位开始依次相加，相加的时候要处理进位
主程序分为三个模块来处理
读数
加法处理
输出
`int main(){
	int a[N],b[N];
	memset(a,0,sizeof(a)); //对a数组进行清零处理，在库<cstring>中
	memset(b,0,sizeof(b));
	Read(a); //读入第一个加数存到a数组中
	Read(b); //读入第一个加数存到b数组中
	Add(a,b); //将a和b加起来，将和存到a数组中
	Out(a); //将和a输出
	return 0;
}`

然后分模块去进行分别处理

`void Read(int a[]){ //读数模块
	string s;
	cin>>s; //用字符串读入该数
	a[0]=s.size(); //存储该数的长度，也可用a[0]=s.length();
	for(int i=1;i<=a[0];i++)
	  a[i]=s[a[0]-i]-'0'; //i和a[0]-i实现下标的倒序，-‘0’实现字符和整数的转换，注意字符串的下标是从0到a[0]-1，整数数组下标是从a[0]到1
	return ;
}`
`void Add(int a[],int b[]){//相加模块
	if(a[0]<b[0])a[0]=b[0]; //和存储在a数组中，a[0]要保证能加到两个数的最高位
	for(int i=1;i<=a[0];i++){
		a[i]+=b[i]; //存储和
		a[i+1]+=a[i]/10; //处理进位，将进位加到上一位去
		a[i]%=10; //去掉进位后的数值。处理进位也可以改成if(a[i]>9) a[i+1]++,a[i]-=10;
	}
	if(a[a[0]+1]>0) a[0]++; //如果最高位上有进位，则结果位数要加一位
	return;
}
void Out(int a[]){
	for(int i=a[0];i>0;i--)cout<<a[i]; //倒序输出每一位，有时候需要处理最高位上有0的情况，具体情况再具体处理
	return;
}`

练习

###### 高精度数+单精度数

Description
　　输入两个整数x,y，输出它们的和。
Input
　　输入两个整数x,y（0 <= x <= 10^100，0<=y<10 ^9）
Output
　　输出它们的和
Sample Input
123456789000
234
Sample Output
123456789234
高精度加法
Description
　　输入两个整数x,y，输出它们的和。
Input
　　输入两个整数x,y（0 <= x,y <= 10^100）
Output
　　输出它们的和
Sample Input
123
234
Sample Output
357
1168（注意前导0）
【题目描述】
求两个不超过200位的非负整数的和。
【输入】
有两行，每行是一个不超过200位的非负整数，可能有多余的前导0。

【输出】
一行，即相加后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。

【输入样例】
22222222222222222222
33333333333333333333
【输出样例】
55555555555555555555

1309：【例1.6】回文数(Noip1999)
【题目描述】
若一个数（首位不为零）从左向右读与从右向左读都是一样，我们就将其称之为回文数。例如：给定一个 10进制数 56，将 56加 65（即把56从右向左读），得到 121是一个回文数。又如，对于10进制数87，
STEP1： 87＋78= 165 STEP2： 165＋561= 726

STEP3： 726＋627＝1353 STEP4：1353+3531=4884

在这里的一步是指进行了一次N进制的加法，上例最少用了4步得到回文数4884。

写一个程序，给定一个N（2＜N＜＝10或N=16）进制数 M．求最少经过几步可以得到回文数。如果在30步以内（包含30步）不可能得到回文数，则输出“Impossible” 。

【输入】
给定一个N（2＜N＜＝10或N=16）进制数M。

【输出】
最少几步。如果在30步以内（包含30步）不可能得到回文数，则输出“Impossible”。

【输入样例】
9 87
【输出样例】
6

兔子繁殖问题
Description
　　有一对小兔,过一个月之后长成大兔,到第四个月就可以生下一对小兔,并且以后每个月都 生下一对小兔。而所生的一对小兔也同样到一个月之后长成大兔,到第四个月就可以生下一 对小兔,并且以后也每个月都生下一对小兔.假设所有的兔子均不死亡，问第n个月后共有多少对兔子？请设计一个程序，解决这一问题。
Input
　　一个正整数n（n <= 5000）
Output
　　第n个月后共有多少对兔子
Sample Input
5
Sample Output
3
解答

###### 高精度数+单精度数

Add模块和main模块有些变化
void Add(int a[],int b){
	a[1]+=b;
	int i=1;
	while(a[i]>9){
		a[i+1]+=a[i]/10;
		a[i]%=10;
		i++;
	}
	if(i>a[0])a[0]=i;
}

int main(){
	int a[N],b;
	memset(a,0,sizeof(a));
	cin>>b;
	Read(a);
	Add(a,b);
	Out(a); 
	return 0;
}

高精度加法
看前面的讲义
1168（注意前导0）
前导0可以在读数的时候处理，嫌麻烦的话直接在输出模块中修改就可以
void Out(int a[]){
	while(a[0]>1&&a[a[0]]==0)a[0]--; //去掉结果数据中前面多余的0
	for(int i=a[0];i>0;i--)cout<<a[i];
	return;
}

兔子繁殖问题
请仔细思考

`#include<iostream>
#include<cstdio>
#include<cstring>
#define N 5005
using namespace std;
void Out(int a[]){
	for(int i=a[0];i>0;i--)
		cout<<a[i];
	cout<<endl;
	return;
}
void Copy(int a[],int b[]){
	memset(b,0,sizeof(b));
	for(int i=0;i<=a[0];i++)
		b[i]=a[i];
	return;
}
void Add(int a[],int b[],int c[] ){
	memset(c,0,sizeof(c));
	c[0]=b[0];
	for(int i=1;i<=b[0];i++){
		c[i]+=a[i]+b[i];//要加上进位，c[i]里边存储了进位
		c[i+1]=c[i]/10; //进位
		c[i]%=10;
	}
	if(c[c[0]+1])c[0]++;
	return;
}
int main(){
	int a1[N],a2[N],a3[N],a4[N],n; //a[n]=a[n-1]+a[n-3] 
	memset(a1,0,sizeof(a1));
	memset(a2,0,sizeof(a2));
	memset(a3,0,sizeof(a3));
	memset(a4,0,sizeof(a4));
	a1[0]=a1[1]=a2[0]=a2[1]=a3[0]=a3[1]=1;
	cin>>n;
	for(int i=4;i<=n;i++){
		Add(a1,a3,a4);
		Copy(a2,a1);
		Copy(a3,a2);
		Copy(a4,a3);
	}
	Out(a3);
	return 0;
}`

1309：【例1.6】回文数(Noip1999)
见信息奥赛一本通教材
16进制数在读数的时候要处理一下
if(s[a[0]-i]>='A'&&s[a[0]-i]<='F') a[i]=s[a[0]-i]-'A'+10;//超过十进制的处理方式
1
回文和反转可以各加一个函数

##### 高精度乘法

###### 高精度乘单精度

单精度数不需要转为数组存储
可以先用高精度数的每一位乘上单精度数，然后再用一个循环来处理进位，这里不可以同加法一样去边乘边处理进位

      999765
 *      3216
-------------
  3215244240

乘法模块中有三个循环

第一个循环，高精度数的每一位乘上单精度数
第二个循环，处理每一位上的进位
第三个循环，处理最高位上的进位
void Mul(int a[],int b){
	for(int i=1;i<=a[0];i++)//单精度数b和高精度数a的每一位相乘
		a[i]*=b;
	for(int i=1;i<=a[0];i++){//处理每一位上的进位
		a[i+1]+=a[i]/10;
		a[i]%=10;
	}	
	while(a[a[0]+1]>0){//最高位上如果有进位则位数a[0]增加后继续处理，可根据情况决定是否要分成一位一位的
		a[0]++;
		a[a[0]+1]=a[a[0]]/10;
		a[a[0]]%=10;
	}
}

练习
1170：计算2的N次方（一本通）
【题目描述】
任意给定一个正整数N(N≤100)，计算2的n次方的值。
【输入】
输入一个正整数N。

【输出】
输出2的N次方的值。

【输入样例】
5
【输出样例】
32

1172：求10000以内n的阶乘
【题目描述】
求10000以内n的阶乘。
【输入】
只有一行输入，整数n（0≤n≤10000）。

【输出】
一行，即n!的值。

【输入样例】
4
【输出样例】
24

1173：阶乘和
【题目描述】
用高精度计算出S=1!+2!+3!+…+n!（n≤50）,其中“!”表示阶乘，例如：5!=5×4×3×2×1。
输入正整数n，输出计算结果S。

【输入】
一个正整数n。

【输出】
计算结果S。

【输入样例】
5
【输出样例】
153

练习解答
1170：计算2的N次方（一本通）
主模块中修改a[0]a[1]的值为1
然后使用n次方的循环进行计算，在循环中放入高精乘单精模块
int main(){
	int a[N],n;
	memset (a,0,sizeof (a));
	a[0]=a[1]=1;//累乘要赋初始值为1
	cin>>n;
	for (int i=1; i<=n; i++) Mul(a);//让a连续乘以n个2
	Out(a); 
	return 0;
}

高精乘单精模块中的单精度数一直为2，这样就是2的n次方

void Mul(int a[]){
	for(int i=1;i<=a[0];i++)//每一位乘以2
		a[i]*=2;
	for(int i=1;i<=a[0];i++){//处理进位
		a[i+1]+=a[i]/10;
		a[i]%=10;
	}	
	while(a[a[0]+1]>0){//处理最高位的进位
		a[0]++;
		a[a[0]+1]=a[a[0]]/10;
		a[a[0]]%=10;
	}
}

1172：求10000以内n的阶乘
10000的阶乘位数有30000多位，运算次数达到上亿次，所以会出现超时的情况，需要进行高精度计算的优化
高精度计算的优化
本题的优化比较简单，直接在存储的时候将十进制改成万进制就可以了
将代码中的10改为10000
注意在输出的时候要做相应的调整，除最高位上的每一位都对应的是4位，即便是2位数，如25，在输出的时候要输出为0025
主模块
`int main(){
	int n;
	a[0]=a[1]=1;
	cin>>n;
	for (int i=2; i<=n; i++) Mul(a,i);
	Out(a); 
	return 0;
}
`
万进制高精度乘单精度

`void Mul(int a[],int b){
	for(int i=1;i<=a[0];i++)
		a[i]*=b;
	for(int i=1;i<=a[0];i++){//将10改为10000就形成万进制存储，循环次数大大减少
		a[i+1]+=a[i]/10000;
		a[i]%=10000;
	}	
	while(a[a[0]+1]>0){
		a[0]++;
		a[a[0]+1]=a[a[0]]/10000;
		a[a[0]]%=10000;
	}
}`

输出的时候要做相应处理

`void Out(int a[]){
	cout<<a[a[0]];//先输出最高位
	for(int i=a[0]-1;i>0;i--) {//其他位不足4位的话前面要用0来占位
		if (a[i]<1000) cout<<0;
		if (a[i]<100) cout<<0;
		if (a[i]<10) cout<<0;
		cout<<a[i];
	}
}`

1173：阶乘和

###### 高精度乘高精度

​       847

 *     295
--------------
      4235
     7623
 +  1694  
--------------
    249865

在纸上写出并仔细分析上面的乘法竖式
因为假设的都是高精度数，只能一位一位来相乘，大致分成以下步骤：

一个高精度数上的每一位乘以另一个高精度数上的每一位（双重循环，实际上就是高精度乘单精度）
将每一个乘积值进行错位累加（在双重循环内）
最后处理累加的这个高精度数的进位
从上面可以看出高精度乘高精度的问题实质为若干个高精度乘单精度之和，即：

先高精度*单精度
再依次高精度+高精度
`#define N 5005
void Mul(int a[],int b[],int c[]){
	int i,j;
	for(i=1;i<=a[0];i++)
		for(j=1;j<=b[0];j++)
			c[i+j-1]+=a[i]*b[j];//用c数组来存储错位累加的和
	c[0]=a[0]+b[0];//位数最多为两个高精度为数之和
	for(i=1;i<=c[0];i++){//处理进位
		c[i+1]+=c[i]/10;
		c[i]%=10;
	}
	while(c[0]>1&&c[c[0]]==0)c[0]--;//处理最高位多余的0，考虑了和0相乘的情况
	return;
}
int main(){
	int a[N],b[N],c[N];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	Read(a);
	Read(b);
	Mul(a,b,c);
	Out(c);
	return 0;
}`

请根据代码写出上面竖式乘法进行计算的过程

               847
 *             295
--------------------------
            40    20   35
    72     36+40 63+20 35
16 8+72 14+36+40 63+20 35  
16  80    90       83  35
249865
前面没有多余0

**AND**

``#define Length 100`

`int *Multi(int *a, int *b ,int la, int lb)
{
	int i, j,*c;`
	`int len;`
	`len = la + lb;`
	`c = (int *)malloc((len) * sizeof(int));`
	`memset(c, 0, sizeof(int)*len);`
	/*高精度乘法的重点，按照人手工进行乘法运算的方式，通过进位的方法计算结果的每一位的值*/

`
	for (i = 0; i<la; i++)//整数a的每一位与b的所有位分别相乘
		for (j = 0; j < lb; j++)
		{
			c[i + j] += a[i] * b[j];//在c[i+j]的位置加上a的第i位与b的第j位的积
			c[i + j + 1] += c[i + j] / 10;//在下一位的位置进位
			c[i + j] = c[i + j] % 10;//在当前位置保留除以10后余数
		}
	return c;
}
int *Str2int(char *str)
{
	int len,i;
	int *num;
	len = strlen(str);
	num = (int *)malloc(len * sizeof(int));
	memset(num, 0, len * sizeof(int));
	for (i = 0; i < len; i++)//对每一位字符进行倒序存放
		num[i] = str[len - i - 1] - '0';//以ASCII码值进行相减，再转换成整型
	return num;
}
char *Int2str(int *num,int len)
{
	int i, j;
	char *res;
	res = (char *)malloc(len * sizeof(char));
	memset(res, 0, len * sizeof(char));
	while (num[len-1] == 0 && len>1)//2个数想乘，结果位数必定小于等于2者位数之和
	{                               //大于等于2者位数之和-1
		len--;
	}
	for (i = 0; i < len; i++)//以ASCII码值进行相加，再转换乘字符串形式
	{
		res[i] = num[len - 1 - i] + '0';
	}
	res[len] = '\0';//添加结束符
	return res;
}
int main()
{
	char *s1, *s2,*s;
	int *a, *b, *c;
	int i,la, lb,len;
	s1 = (char *)malloc(Length * sizeof(char));//使用指针进行操作时，需要先分配内存
	s2 = (char *)malloc(Length * sizeof(char));
	memset(s1, 0, sizeof(char)*(Length));//初始化分配的内存，置0
	memset(s2, 0, sizeof(char)*(Length));
	cin >> s1 >> s2;
	la = strlen(s1);//统计字符串长度，不包括结束符'\0'
	lb = strlen(s2);
	len = la + lb;
	a = Str2int(s1);//字符转整型
	b = Str2int(s2);
	c=Multi(a, b, la, lb);//重点：高精度乘法
	s = Int2str(c,len);//整型转字符
	cout << s;
	return 0;
}`

练习
1307：【例1.3】高精度乘法
【题目描述】
求两个不超过200位的非负整数的积。
【输入】
有两行，每行是一个不超过200位的非负整数，没有多余的前导0。

【输出】
一行，即相乘后的结果。结果里不能有多余的前导0，即如果结果是342，那么就不能输出为0342。

【输入样例】
12345678900
98765432100
【输出样例】
1219326311126352690000

练习解答见讲解

##### 高精度减法

先在纸上书写几个代表性的减法式子并进行分析，提炼出处理模块

     90
  - 215
---------
  - 125

   3100
  - 215
---------
   2885

     190
  -  190
---------
       0

首先要比较两个高精度数的大小
分为三种情况

a==b相等则输出0
a>b，计算a-b并输出
a<b，输出 - 号，计算b-a并输出
计算的时候存在着向高位借位的情况
处理差的位数
	927
-	896
-----------
	  1	7-6=1
	     3	   12-9=3,借位12
	0	(9-1)-8=0
-----------
	 31

主模块可编写如下：

`int main(){
	int a[N],b[N],f;
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	Read(a);
	Read(b);
	f=Comp(a,b);
	if(f==0){
		cout<<0;
		return 0;
	}
	if(f>0) {
		Minus(a,b);
		Out(a);
	}
	else {
		cout<<'-';
		Minus(b,a);
		Out(b);
	}
	return 0;
}`

比较模块

`int Comp(int a[],int b[]){//比较a和b的大小关系，若a>b则为1，a<b则为-1,a=b则为0 
     if(a[0]>b[0])return 1;   //a的位数大于b,则a比b大 
     if(a[0]<b[0])return -1;  //a的位数小于b,则a比b小 
     for(int i=a[0];i>0;i--) { //否则a和b的位数相同，则从高位到低位比较 
         if(a[i]>b[i])return 1; 
         if(a[i]<b[i])return -1;
     } 
     return 0;//各位都相等则两数相等。 	
}`

减法模块

`void Minus(int a[],int b[]){//计算a=a-b
      for(int i=1;i<=a[0];i++){
      	if(a[i]<b[i]){ a[i+1]--;a[i]+=10;} //若不够减则向上借一位 
         a[i]=a[i]-b[i]; 
      } 
      while(a[0]>0&&a[a[0]]==0) a[0]--; //修正a的位数 
      return;
} `

练习
1169：大整数减法
【题目描述】
求两个大的正整数相减的差。
【输入】
共2行，第1行是被减数a，第2行是减数b(a > b)。每个大整数不超过200位，不会有多余的前导零。

【输出】
一行，即所求的差。

【输入样例】
9999999999999999999999999999999999999
9999999999999
【输出样例】
9999999999999999999999990000000000000

练习解答
见讲解

##### 高精度除法

###### 高精度除单精度

在纸上写出除式并进行分析

竖式除法

36   商

12345 √ 452678
        37035	 12345*3=37035
         8232	 45267-37035=8232
         82328	 进行下一位处理
         74070	 12345*6=74070
          8258	 82328-74070=8258 余数

被除数的第一位和除数比较，比它小的话就再加一位，否则就可以计算商和余数，然后再用余数来加一位进行循环处理
实际处理的时候不用比较，小的话商就为0，输出结果的时候将商高位的0去掉就可以,主模块比较简单,读数,相除,输出商和余数

`int y;//存储余数
int main(){
	int a[N],c[N],b;
	memset(a,0,sizeof(a));
	memset(c,0,sizeof(c));
	Read(a);
	cin>>b;
	Div(a,b,c);
	cout<<y<<endl;
	Out(c);
	return 0;
}`

`void Div(int a[],int b,int c[]){
	c[0]=a[0]; //商的位数
	for(int i=a[0];i>0;i--){
		y=y*10+a[i]; //被除数，每次处理一位
		c[i]=y/b; //商
		y%=b; //余数
	}
	while(c[0]>1&&c[c[0]]==0)c[0]--; //去掉高位上多余的0
	return;
}`

练习
1171：大整数的因子
【题目描述】
已知正整数k满足2≤k≤9，现给出长度最大为30位的十进制非负整数c，求所有能整除c的k。
【输入】
一个非负整数c，c的位数≤30。

【输出】
若存在满足 c%k == 0 的k，从小到大输出所有这样的k，相邻两个数之间用单个空格隔开；若没有这样的k，则输出"none"。

【输入样例】
30
【输出样例】
2 3 5 6

1175：除以13
【题目描述】
输入一个大于0的大整数N，长度不超过100位，要求输出其除以13得到的商和余数。
【输入】
一个大于0的大整数，长度不超过100位。

【输出】
两行，分别为整数除法得到的商和余数。

【输入样例】
2132104848488485
【输出样例】
164008065268345

练习解答
1171：大整数的因子
见讲义，简单修改一下主程序即可
	for(int k=2;k<10;k++)
		if(Div(a,k)==0) cout<<k<<' ';

1175：除以13
见讲义，简单修改即可

###### 高精度除高精度

思路：需要转化为减法来进行计算
先在纸上进行分析

两个数均为高精度数的时候，无法使用高精度除以单精度的方法
但在分析的时候，还是可以用两个较小的数来分析
如：a=12346578, b=139, 求 a÷b
在139后面填充0，使其位数与被除数一致，然后看被除数中包含了几个，这个可以用减法来实现
             088824
       ------------------   //tmp=13900000，139后面填充5个0，填充的0的个数为a[0]-b[0]+1
 139  /    12346578 //第一次商为0，Comp(a,tmp)，第二次将139后面的0减少1位
           11120000 //a比tmp大时，循环执行Minus(a,tmp)，直到a<tmp，每减1次，商c[i]++
            1226578 //循环处理
            1112000
             114578
             111200
             003378
               2780
               0598
                556
                 42 //最后剩下的a就是余数

`int Comp(int a[],int b[]){
	int i;
	if(a[0]>b[0])return 1;
	if(a[0]<b[0])return -1;
	for(i=a[0];i>0;i--){
		if(a[i]>b[i])return 1;
		if(a[i]<b[i])return -1;
	}
	return 0;
}
void numcopy(int b[],int t[],int i){
	t[0]=b[0]+i-1; //t的位数，全部数字为0
	for(int j=b[0];j>0;j--)
		t[i+j-1]=b[j]; //将t数组的高位全部赋为b数组
}
void Div(int a[],int b[],int c[]){
	int i,j,t[N];
	c[0]=a[0]-b[0]+1;//商的最大位数
	for(i=c[0];i>0;i--){
		memset(t,0,sizeof(t));
		numcopy(b,t,i); //在b后面添加0，每次循环的时候0的个数会减少1，为方便处理，将其拷贝到t数组中。上一句话中已经将t数组全部赋0了，numcpy中只需要将b数组的每一位拷贝到t数组的高位就可以了
		while(Comp(a,t)>=0){//a比t大的时候就统计a中包含了多少个t(个数<10)
			c[i]++; //包含的个数就是第i位上的商
			Minus(a,t);  //标准减法模块
		}
	}
	while(c[0]>0&&c[c[0]]==0)c[0]--;//去掉商高位上多余的0
}
int main(){
	int f,a[N],b[N],c[N];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	Read(a); //标准读数模块
	Read(b);
	f=Comp(a,b);//根据a和b之间的三种大小关系分别处理，比较大小是标准模块
	if(f==0){ //相等则商为1，余数为0
		cout<<1<<endl<<0;
		return 0;
	}
	if(f==-1){ //a<b则商为0，余数为a
		cout<<0<<endl;
		Out(a);
		return 0;
	}
	Div(a,b,c); //a>b时进行高精度除法，c用来存储商，余数最终存在a中
	Out(c);  //标准输出模块
	Out(a);
	return 0;
}`
1308：【例1.5】高精除
【题目描述】
高精除以高精，求它们的商和余数。
【输入】
输入两个低于300位的正整数。

【输出】
输出商和余数。

【输入样例】
1231312318457577687897987642324567864324567876543245671425346756786867867867
1231312318767141738178325678412414124141425346756786867867867
【输出样例】
999999999748590
179780909068307566598992807564736854549985603543237528310337

练习解答
1308：【例1.5】高精除
见讲义
高精度数的优化
如果只是针对加减法的话可以采用亿进制来优化，乘法的话考虑万进制（不超出int或long long的范围）
前面有一个高精度数优化的实例
优化的时候，主要是读数和输出模块上略有变化，其他只需要修改相应的进制基数就可以了

读数模块
123456
万进制表示为：a[0]=2,a[2]=12,a[1]=3456
6位变成2位，减少计算次数
void Read(int a[]){ //读数模块
	string s;
	cin>>s;
	int len=s.size(); 
	for(int i=0; i<len; i++)
	   a[(len+3-i)/4]=a[(len+3-i)/4]*10+s[i]-'0'; //(len+3-i)/4，处理每一个万进制位上的值
	a[0]=(len+3)/4; //万进制的位数
	return ;
}
1
2
3
4
5
6
7
8
9
输出模块
void Out(int a[]){
	cout<<a[a[0]];//先输出最高位，最高位前面不需要多加0
	for(int i=a[0]-1;i>0;i--){ //除最高位外的其他位都要输出4位（万进制）
		cout<<a[i]/1000;
		cout<<a[i]/100%10;
		cout<<a[i]/10%10;
		cout<<a[i]%10; 
	}
1
2
3
4
5
6
7
8
练习
高精度乘法
求a和b的乘积，0<a,b<10^ 20000
样例输入：
2
3
样例输出：
6
练习解答
略

综合练习
求组合公式C(n,m)的值，C(n,m)=n!/(m!(n-m)!)
样例输入：
6 2
样例输出：
15
奇怪的贸易
【问题描述】
刚结束了CS战斗的小D又进入了EVE的游戏世界,在游戏中小D是一名商人,每天要做的事情就是在这里买东西,再运到那里去卖.这次小D来到了陌生的X星,X星上有n种货物,小D决定每种都买走一些,他用ai来表示第i种货物购买的数量,X星人对物品的单价有特别的决定方式.他们首先会选择一个基本价x,第一种物品单价为x,第二种物品单价为x ^ 2,第三种物品单价为x ^ 3……第i种物品单价为x^i.结算总价时,你还需要给他们一笔手续费a0,小D不知道自己带的钱是否能够进行这笔交易,所以请你帮助他计算这笔交易他要支付的总金额是多少.
【输入文件】
　　第一行两个数分别表示基准价x (x<=10),物品种数n (n<=100000)
　　第二行一个数,手续费a0 (a0<=100)
　　接下来的n行每行一个数,第i行表示第i种物品购买的数量(ai<=100)
【输出文件】输出结果的最后100位,若不足100位请高位用零补足
【样例输入】
2 3
4
3
2
1
【样例输出】 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000026
综合练习解答
求组合公式C(n,m)的值，C(n,m)=n!/(m!(n-m)!)
直接根据公式为：高精度乘再加一个高精度除
也可以做一些变化
奇怪的贸易
高精度乘以单精度，高精度和

### vector

##### 加法

`#include<iostream>
#include<vector>
using namespace std;
vector<int> add(vector<int> &A,vector<int> &B)
{
    vector<int> C;
    int t=0;//t表示进位
    for(int i=0;i<A.size()||i<B.size();i++)
    {
        if(i<A.size()) t+=A[i];
        if(i<B.size()) t+=B[i];
        C.push_back(t%10);
        t=t/10;
    }
    if(t) C.push_back(1);//表示当A,B数组都操作完成后，t=1，说明应该进一位。
    return C;
}
int main()
{
    string a,b;
    cin>>a>>b;
    vector<int> A,B;
    for(int i=a.size()-1;i>=0;i--) A.push_back(a[i]-'0');
    for(int i=b.size()-1;i>=0;i--) B.push_back(b[i]-'0');
    auto C=add(A,B);
    for(int i=C.size()-1;i>=0;i--)
    cout<<C[i];
    return 0;
}`

##### 减法

`#include<iostream>
#include<vector>
using namespace std;
vector<int> add(vector<int> &A,vector<int> &B)
{
    vector<int> C;
    int t=0;//t表示进位
    for(int i=0;i<A.size()||i<B.size();i++)
    {
        if(i<A.size()) t+=A[i];
        if(i<B.size()) t+=B[i];
        C.push_back(t%10);
        t=t/10;
    }
    if(t) C.push_back(1);表示当A,B数组都操作完成后，t=1，说明应该进一位。
    return C;
}
int main()
{
    string a,b;
    cin>>a>>b;
    vector<int> A,B;
    for(int i=a.size()-1;i>=0;i--) A.push_back(a[i]-'0');
    for(int i=b.size()-1;i>=0;i--) B.push_back(b[i]-'0');
    auto C=add(A,B);
    for(int i=C.size()-1;i>=0;i--)
    cout<<C[i];
    return 0;
}`

##### 乘法

`#include<iostream>
#include<vector>
using namespace std;
vector<int> mul(vector<int> &A,int b)
{
    vector<int> C;
    int t=0;
    for(int i=0;i<A.size()||t!=0;i++)//注意循环的判断条件，如果A操作完而t！=0说明还需要进位
    {
        if(i<A.size()) t=t+A[i]*b;
        C.push_back(t%10);//这里对t的操作与加法相同，可联系记忆。
        t=t/10;
    }
    while(C.size()>1&&C.back()==0) C.pop_back();//去掉前置0
    return C;
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--) A.push_back(a[i]-'0');
    auto C=mul(A,b);
    for(int i=C.size()-1;i>=0;i--)
    cout<<C[i];
    return 0;
}`

##### 除法

`#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
vector<int> div(vector<int> &A,int b,int &t)
{
    vector<int> C;
    t=0;
    for(int i=A.size()-1;i>=0;i--)//注意
    {
        t=t*10+A[i];
        C.push_back(t/b);
        t=t%b;
    }
    reverse(C.begin(),C.end());//注意
    while(C.size()>1&&C.back()==0) C.pop_back();
    return C;
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    int t;
    vector<int> A;
    for(int i=a.size()-1;i>=0;i--) A.push_back(a[i]-'0');
    auto C=div(A,b,t);
    for(int i=C.size()-1;i>=0;i--)
    cout<<C[i];
    cout<<endl<<t;
    return 0;
}`

## 进制转换

`const int MAXN = 1000;
int  t[MAXN], A[MAXN];
char OldData[MAXN], NewData[MAXN];  // 转换前、后的数据
int olds, news;   `                  // 转换前、后的进制

// 调用方式：输入olds、news、OldData，然后调用trans(),输出NewData`
void trans()
{
    int i, len, k;
    len = strlen(OldData);
    for(i=len; i>=0; --i)
        t[len-1-i] = OldData[i] - (OldData[i]<58 ? 48 : OldData[i]<97 ? 55 : 61);
    for(k=0; len;)
    {
        for(i=len; i>=1; --i)
        {
            t[i-1] += t[i]%news*olds;
            t[i] /= news;
        }
        A[k++] = t[0] % news;
        t[0] /= news;
        while(len>0 && !t[len-1]) --len;
    }
    NewData[k] = NULL;
    for(i=0; i<k; ++i)
        NewData[k-1-i] = A[i] + (A[i]<10 ? 48 : A[i]<36 ? 55 : 61);
}`



```c++
/*
高精度进制转换 
把oldBase 进制的数转化为newBase 进制的数输出。
调用方法，输入str, oldBase newBase.
change();
solve();
output();
也可以修改output(),使符合要求，或者存入另外一个字符数组，备用 
*/
#include<stdio.h>
#include<string.h>
#defien MAXSIZE 1000
char str[MAXSIZE];//输入字符串
int start[MAXSIZE],ans[MAXSIZE],res[MAXSIZE];//被除数，商，余数
int oleBasw,newBase;//转换前后的进制

//单个字符得到数字
int getNum(char c)//这里进制字符是先数字，后大写字母，后小写字母的 
{
    if(c>='0'&&c<='9') return c-'0';//数字 
    if(c>='A'&&c>='Z') return c-'A'+10;//大写字母 
    return c-'a'+36;//小写字母 
}    
//数字得到字符
char getChar(int i)
{
    if(i>=0&&i<=9)return i+'0';
    if(i>=10&&i<=35)return i-'10'+'A';
    return i-36+'a';
}     
void change()//把输入的字符串的各个数位还原为数字形式
{
    int i;
    start[0]=strlen(str);//数组的0位存的是数组长度
    for(i=1;i<=start[0];i++)
        start[i]=getNum(str[i-1]); 
}    
void solve()
{
    memset(res,0,sizeof(res));//余数位初始化为空
    int y,i,j;
    while(start[0]>=1) 
    {
        y=0;i=1;
        ans[0]=start[0];
        while(i<=start[0])
        {
            y=y*oldBase+start[i];
            ans[i++]=y/newBase;
            y%=newBase;
        }    
        res[++res[0]]=y;//这一轮得到的余数
        i=1;//找下一轮商的起始处，去掉前面的0
        while(i<=ans[0]&&ans[i]==0) i++;
        memset(start,0,sizeof(start));
        for(j=i;j<ans[0];j++)
           start[++start[0]]=ans[j];
        memset(ans,0,sizeof(ans)); 
    }    
}  
void output()//从高位到低位逆序输出 
{
    int i;
    for(i=res[0];i>=1;i--)
        printf("%d",getChar(res[i]));
    printf("\n");
} 
```

## 位运算

> 位运算就是直接对整数在内存中的二进制位进行操作。

**常用的几种位运算**

- 与 (`&`) and

当两个数在二进制下对应位数上**均**为 1 时，得到的结果为 1.

- 或 (`|`) or

当两个数在二进制下对应位数上**有一个**为 1 时，得到的结果为 1.

- 异或 (`^`) xor

当两个数在二进制下对应位数上**不相同**时，得到的结果为 1.

- 左移 (`<<`)

将一个数在二进制下整体向左移位

- 右移 (`>>`)

将一个数在二进制下整体向右移位.

举个栗子：

 7=(00000111)2

11=(00001011)2

7 and 11=(00000011)2=3

7 or 11=(00001111)2=15

7 xor 11=(00001100)2=12

7<<1=(00001110)2=14

7>>1=(00000011)2=3

通常情况下，左移一位表示将这个数乘以2，右移一位表示将这个数除以2，**向下取整**.

然后，对于这份代码，其实所谓的万无一失是不必要的，因为在做左移或者右移的时候，多余的位数就已经自动溢出了，所以可以省略不写.

另外，关于0x0000ffff 这样的以 0x 开头的数据，是十六进制表示法，每一位满 1616 进 11，用 0 ~F 表示.

## DFS

> 一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)
>
> 在深度优先搜索中，每当扫描到已发现的顶点u的邻接表，从而发现新顶点v时，就将置v的先辈域Π[v]为u。与广度优先搜索不同的是，其先辈子图形成一棵树，深度优先搜索产生的先辈子图可以有几棵树所构成，因为搜索可能由多个源顶点开始重复进行。因此，在深度优先搜索中，先辈子图的定义也和广度优先搜索中稍有所不同：GΠ = (V, EΠ)，其中EΠ = {(Π[v], v) : v ∈V 且 Π[v] ≠ NIL}
> 

key：递归求解问题的思路以及回溯的处理

在实际的操作中，我们一般对深度优先搜索问题进行分类：

1. 定义的DFS：对图的连通性进行测试，典型的问题：迷宫连通性测试、图的条件搜索等
2. 广义的DFS–DFS思路的应用：DFS搜索顺序+规则问题、穷举结果寻求最优解/符合条件解等等，由于其穷举答案的本质，又被称为爆搜

**基本模板**

int check(参数)
{
    if(满足条件)
        return 1;
    return 0;
}

void dfs(int step)
{
        判断边界
        {
            相应操作
        }
        //尝试每一种可能
        {
               满足check条件
               标记
               继续下一步dfs(step+1)
               恢复初始状态（回溯的时候要用到）//视情况
        }
}   

**优化**

针对搜索的过程，又有更为重要的剪枝、优化，必要的剪枝优化(通过对穷举答案方式进行改进)对DFS的顺利执行有着不可或缺的作用

针对实际问题，将连通性模型按照是否需要回溯继续细分：

1. 1.无需回溯：统计某点能到达的点的个数问题
在这类问题中，我们一般从某点出发进行搜索，对于已经被搜索过的点可以直接抛弃(标记不可访问)，对于当前被搜索的点递归搜索周围邻接的点并进行计数，直到无法搜索到合法的点返回。最终计数变量将记录所有能到达的点。

典型模板题：ACWing.1113 红与黑

解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109243556X

1. 2.需要回溯：迷宫类问题，测试两点间连通性
   在这类问题中，由于当前选择的路径未必能够到达目标点，因此需要设置回溯，当搜索到非法路径返回时需要“恢复现场”，即：对于该路径下各点的访问状态重置。具体的搜索过程如下图所演示：


![img](https://img-blog.csdnimg.cn/20201110173058707.gif#pic_center)

典型模板题：ACWing.1112 迷宫

解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109239579

典型模板题：ACWing.1116 马走日

解题报告：https://blog.csdn.net/yanweiqi1754989931/article/details/109247649

这题堪称经典，与迷宫模板不同的是移动路径的选择和点合法性的判断，属于简单的搜索题



根据数据结构，又可以将两个模型分别继续细分，

DFS可以基于邻接矩阵、邻接表、边集数组实现，思路相同，只是路径的遍历方式、点的访问有所改变。

`function dfs(当前状态){
	if(当前状态 == 目的状态){
        ···
    }
    for(···寻找新状态){
        if(状态合法){
            vis[访问该点]；
            dfs(新状态);
            ?是否需要恢复现场->vis[恢复访问]
        } 
    }
    if(找不到新状态){
        ···
    }
}`

### **DFS思路应用-穷举求解问题**

在无路可走时，我们往往会选择搜索算法，因为我们期望利用计算机的高性能来有目的的穷举一个问题的部分甚至所有可能情况，从而在这些情况中寻找符合题目要求的答案。这也是“爆搜”之名的由来

我们约定，对于问题的介入状态，叫初始状态，要求的状态叫目标状态。
这里的搜索就是对实时产生的状态进行分析检测，直到得到一个目标状态或符合要求的最佳状态为止。对于实时产生新的状态的过程叫扩展（由一个状态，应用规则，产生新状态的过程）

**搜索的要点：**
***选定初始状态，在某些问题中可能是从多个合法状态分别入手搜索；**

**遍历自初始状态或当前状态所产生的合法状态，产生新的状态并进入递归；**

**检查新状态是否为目标状态，是则返回，否则继续遍历，重复2-3步骤**

**对状态的处理：DFS时，用一个数组存放产生的所有状态。**
**把初始状态放入数组中，设为当前状态；***
**扩展当前的状态，从合法状态中旬寻找一个新的状态放入数组中，同时把新产生的状态设为当前状态；
判断当前状态是否和前面的状态重复，如果重复则回到上一个状态，产生它的另一状态；
判断当前状态是否为目标状态，如果是目标目标状态，则找到一个解答，根据实际问题需求，选择继续寻找答案或是直接返回。
如果数组为空，说明对于该问题无解。**
⭐与图的搜索类似，算法的框架基本不变，不同的是对于新状态的寻找、控制递归终止的条件更为复杂。

在实际的题目中，会有一些题目需要对合法的新状态进行干预：可能在首轮搜索无法应用规则或所有条件均不满足且需要人为创建新的规则以继续搜索答案。这里也会设计到一系列剪枝与优化的问题。


`function dfs(当前状态, 一系列其他的状态量){
	if(当前状态 == 目的状态){
        ···
    }
    for(···寻找新状态){
        if(状态合法){
            vis[访问该点]；
            dfs(新状态);
            ?是否需要恢复现场->vis[恢复访问]
        } 
    }
    if(找不到新状态){
        是否需要创建新规则？{
            创建并对当前状态进行访问vis;
            继续搜索;
            恢复现场/恢复访问vis;
        }
    }
}`

exemple:ACWing分成互质组:

题目描述：
给定 n 个正整数，将它们分组，使得每组中任意两个数互质。至少要分成多少个组？

输入格式
第一行是一个正整数 n。

第二行是 n 个不大于10000的正整数。

输出格式
一个正整数，即最少需要的组数。

数据范围
1≤n≤10

输入样例：
6
14 20 33 117 143 175
1
2
输出样例：
3
1
题目分析与算法设计：
给定n个数字分成互质组，那么考虑最坏的情况，要分成n组(n个数均不互质)。因为题目的数据量并不大，可以采用DFS解决，具体思路如下：

预备工作：准备一个数组存输入数据，准备一个容器，用于存不同的组，准备一个检索函数，可以检索指定分组内是否存在与目的数字重合的

**开始DFS：**首先是递归终止条件，判断是否搜到末尾，搜到末尾则更新组数计数的值，返回；
**继续：**每次在已有分组中从头开始搜索，用检索函数判断当前数字是否可以加入分组，若可以，加入后递归向下一个数字搜索
**新建分组：**考虑组数为0的情况、找不到可以加入组的情况，应该设置创建新分组的情况，加入新分组后，同样递归向后搜索。
`#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 11;
int n, p[N], cnt, ans = N;
vector<int> num[N];	//这里使用STL中的Vector，其长度可变，更方便模拟分组的状态`

`int gcd(int x, int y){
    return y ? gcd(y, x % y) : x;	//辗转相除求最大公约数
}`

//判断两数是否互质
`bool check(int x, int t){
    for (int i = 0; i < num[t].size(); i++){
        if (gcd(x, num[t][i]) > 1) return false;
    }
    return true;`

`void dfs(int now)
{
    if (now == n){
        ans = min(ans,  cnt);	//每次搜完取最小组数
        return;
    }`
  `  for (int i = 0; i <  cnt; i++){
        if (check(p[now], i)){
            num[now].push_back(p[now]);
            dfs(now + 1);
            num[i].pop_back();
        }
    }`
    //需要考虑首次搜索无组可加、当前状态无组可加
   ` num[cnt++].push_back(p[u]);
    dfs(now + 1);
    num[--cnt].pop_back(); 
}`

`int main(){
    cin >> n;
    for (int i = 0; i < n; i++) cin >> p[i];
    dfs(0);`
`    cout << ans << endl;
    return 0;`
`}`

### 剪枝优化、题型归纳总结

概述：剪枝与优化
①.剪枝与优化的原则
1.正确性

剪枝优化的过程是使算法逼近最优解的过程，而不是使算法远离最优解甚至跳过最优解的过程。剪枝的前提是保证对最优解不丢不漏。

2.准确性

在保证正确性的前提下，我们采取必要的手段使算法跳过一定不含有目标状态/最优解的分支，从而保证算法高效地进行并更迅速的找出

3.高效性

设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的。

#### ②剪枝与优化的一般入手点

1.优化搜索顺序：

在一些题目中，可以通过对子问题分支进行分析，先解决相对简单的子问题从而使尚未解决的子问题得到简化，通过对搜索顺序的优化可以实现这一点。

2.排除冗余信息：

对限制条件进行分析，不要额外添加没有意义的搜索规则

3.可行性剪枝：

对于显然不包含目标状态的搜索方向及时停止搜索，转而向可能包含目标状态的分支进行搜索

4.最优性剪枝：

每次搜索完成后更新当前得到的最优状态/最优解，在每次搜索开始前判断当前解是否已经比上次得出的状态/解更劣？如果是则停止本次搜索，转向其他搜索分支

5.记忆化搜索：

1.问题的转化、数据的预处理与压缩
在解决实际问题时，我们可以巧妙地对题目给出的数据进行适当的转化，从而构造出DFS的模型进行求解。

这与数学上的构造函数思想类似，在掌握题目数据的基础上对数据进行预处理从而构造可以按照某规则进行检索的新数据，通过对新数据进行搜索从而得出原数据符合要求的解。

对于问题的转化：这里举一个有趣的题目作为例子：ACWing.1117 单词接龙，本题有一种解法便是在读入单词数目后初始化一张邻接表，用于表示对应序号的两个单词重叠部分的长度，同时再设置一个访问状态数组，这样就可以在表中进行搜索，每搜索完一轮更新最长长度，最终得到的便是最长“龙”的长度。
example:
题目描述
单词接龙是一个与我们经常玩的成语接龙相类似的游戏。

现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。

在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。

我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。

输入格式
输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。

你可以假定以此字母开头的“龙”一定存在。

输出格式
只需输出以此字母开头的最长的“龙”的长度。

输入样例：
5
at
touch
cheat
choose
tact
a
输出样例：
23
提示：连成的“龙”为 “atoucheatactactouchoose”。
#include <bits/stdc++.h>
#define N 26
using namespace std;

vector<int> ver[N],edge[N];//匹配的单词编号和匹配长度
string word[N];
int n, res;
int st[N];

void dfs(string u, int k)
{
    st[k] ++;
    res = max(res, (int)u.size());

    for(int i = 0;i < ver[k].size(); i++)
    {
        int point = ver[k][i],d = edge[k][i];
        if(st[point]<2)
            dfs(u + word[point].substr(d), point);
    }
    st[k]--;
}

int main(){
    cin >> n;
    for(int i=1;i<=n;i++) cin >> word[i];

```c++
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        string a = word[i] , b = word[j];
        int len = min(a.size(),b.size());
        for(int k=1;k<len;k++)
        {
            if(a.substr(a.size()-k)==b.substr(0,k))
            {
                ver[i].push_back(j);
                edge[i].push_back(k);
                break;
            }
        }
    }

string head;
cin >> head;
for(int i = 1; i <= n; i++)
    if(head[0] == word[i][0]) dfs(word[i], i);
cout << res << endl;
return 0;
```
}

对于数据的预处理和规模压缩，这里同样举一个非常巧妙地例子：数独

题目描述
数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。

请编写一个程序填写数独。

输入格式
输入包含多组测试用例。

每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。

每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。

您可以假设输入中的每个谜题都只有一个解决方案。

文件结尾处为包含单词“end”的单行，表示输入结束。

输出格式
每个测试用例，输出一行数据，代表填充完全后的数独。

输入样例：
4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......
......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.
end

输出样例：
417369825632158947958724316825437169791586432346912758289643571573291684164875293
41683752998246537173512946857129864329374618586435129764791385235968271412857493
————————————————
题目分析：
本题目数据量较大，用爆搜解决超时是个问题，因此如何优化剪枝便成了重点，下面是需要进行的准备工作，这些预处理极其关键！：

借鉴自yxc大佬的思路，本题可以用二进制位表示的方法巧妙地解决，因此需要提前准备一些数位转换的表以便使用

数组map：在进行lowbit运算时，将返回值转换成对应的含义(数字)
数组ones：每个数的二进制表示中有几个1
数组sudoku：存放原始数据和解
数组row、col，cell，表示每行可供选择的数、每列可供选择的数，每个3*3方格可供选择的数
函数lowbit：返回一个数字的二进制表达式中最低位的1所对应的值
函数makeg：制作两张查询表：ones、map，以便搜索时查询
函数init：初始化数组row、col，cell，从输入的数据中检索每行每列的合法数字
函数get：找到数组row、col，cell的交集，即满足条件的合法数字
函数dfs：深搜解题
dfs的思路(借鉴自yxc大佬)：
开始时判断是否搜索成功，若成功则返回
！优化：找出备选方案数最少的空格，先填它，从而实现整体的优化
找出能填的数字怼上去试试，能行继续搜，搜到底return上来true，搜不到返回false，那么恢复现场，继续找数搜
————————————————

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int N = 9;
int map[1 << N], ones[1 << N];
int row[N], col[N], cell[3][3];
char sudoku[100];

inline int lowbit(int x){
    return x & (-x);
}

inline int get(int x, int y){
    return row[x] & col[y] & cell[x / 3][y / 3];
}

void makeg(){
    for(int i = 0; i < N; i++) map[1 << i] = i;
    for(int i = 0, k = 0; i < (1 << N); i++, k = 0){
        for(int j = i; j; j -= lowbit(j)) k++;
        ones[i] = k;
    }
}

void init(){
    for (int i = 0; i < N; i++) row[i] = col[i] = (1 << N) - 1;
    for(int i = 0; i < 3 ; i++)
        for(int j = 0; j < 3; j++) cell[i][j] = (1 << N) - 1;
}

bool dfs(int cnt){
    //搜索成功结束
    if(!cnt) return true;
    //找出备选数字数目最少的空格
    int minn = 10;
    int x, y;
    for(int i = 0; i < N; i++){
        for(int j = 0; j < N; j++){
            if(sudoku[i * 9 + j] == '.'){
                int tmp = ones[get(x, y)];
                if(tmp < minn) minn = tmp, x = i, y = j;
            }
        }
    }
    for(int i = get(x, y); i; i -= lowbit(i)){
        int tmp = map[lowbit(i)];
        row[x] -= 1 << tmp;
        col[y] -= 1 << tmp;
        cell[x / 3][y  /3] -= 1 << tmp;
        sudoku[x * 9 + y] = '1' + tmp;
        if(dfs(cnt - 1)) return true;
        row[x] += 1 << tmp;
        col[y] += 1 << tmp;
        cell[x / 3][y / 3] += 1 << tmp;
        sudoku[x * 9 + y] = '.';
    }
    return false;
}

int main(){
    makeg();
    while(cin >> sudoku,  sudoku[0] != 'e'){
        init();
        int cnt = 0;
        for(int i = 0, k = 0; i < N; i++){
            for(int j = 0; j < N; j++, k++){
                if(sudoku[k] != '.'){
                    int tmp = sudoku[k] - '1';
                    row[i] -= 1 << tmp;
                    col[j] -= 1 << tmp;
                    cell[i / 3][j / 3] -= 1 << tmp;
                }
                else cnt++;
            }
        }
        dfs(cnt);
        cout << sudoku << endl;
    }
    return 0;
}

```

从本题中可以看出，通过合理利用位运算使运算和数据的规模极大的得到了缩小，因此，合理利用巧解法可以优化搜索算法。但这类思路通常难以想到，需要大量的刷题经验积累。

2.分组问题
典型的例题：分成互质组： 给定 n 个正整数，将它们分组，使得每组中任意两个数互质。至少要分成多少个组？

给定n个数字分成互质组，那么考虑最坏的情况，要分成n组(n个数均不互质)。因为题目的数据量并不大，可以采用DFS解决，具体思路如下：

预备工作：准备一个数组存输入数据，准备一个容器，用于存不同的组，准备一个检索函数，可以检索指定分组内是否存在与目的数字重合的

开始DFS：首先是递归终止条件，判断是否搜到末尾，搜到末尾则更新组数计数的值，返回；
继续：每次在已有分组中从头开始搜索，用检索函数判断当前数字是否可以加入分组，若可以，加入后递归向下一个数字搜索
新建分组：考虑组数为0的情况、找不到可以加入组的情况，应该设置创建新分组的情况，加入新分组后，同样递归向后搜索。

```c++
//dfs搜索函数的框架：
void dfs(int now)
{
    if (now == n){
        ans = min(ans,  cnt);	//每次搜完取最小组数
        return;
    }
    for (int i = 0; i <  cnt; i++){
        if (check(p[now], i)){	//check函数为检查两数是否互质的函数
            num[now].push_back(p[now]);
            dfs(now + 1);
            num[i].pop_back();
        }
    }
    //需要考虑首次搜索无组可加、当前状态无组可加
    num[cnt++].push_back(p[u]);
    dfs(now + 1);
    num[--cnt].pop_back(); 
}

```

3.求最小分组数问题
请区分2！这里使求最小分组数，即存在多组可能的分组方案，

剪枝的基本思路：对于每组数据定长或有最大长度，用vector储存每组长度，如果存不下则新建分组。每轮搜索完毕更新最小组数，每次搜索开始判断当前分组数量是否已经超过历史最优解数量，如果是，放弃该搜索分支。
典型的例题：小猫爬山

### 4.求最大分组长度

预处理的时候要求出合法的分组长度，对于合法长度存在的区间也要进行分析，例如：

ACWing.167 木棒 DFS+剪枝

题目描述
乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。

然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。

请你设计一个程序，帮助乔治计算木棒的可能最小长度。

每一节木棍的长度都用大于零的整数表示。

输入格式
输入包含多组数据，每组数据包括两行。

第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。

第二行是截断以后，所得到的各节木棍的长度。

在最后一组数据之后，是一个零。

输出格式
为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。

数据范围
数据保证每一节木棍的长度均不大于50。

输入样例：
9
5 2 1 5 2 1 5 2 1
4
1 2 3 4
输出样例：
6
5
解题思路分析
需要的准备工作如下：

一个数组stick：用于存放题目的输入
一个数组vis：记录对每根木棒的访问
变量cnt：用于记录总的木棍数
变量len：用于dfs前找到合法的长度并记录
变量group：分组数
变量total：记录总长度
下面分析解题思路：

木棒的原始长度未知，但是所有木棒的总长度已知，因此我们可以通过枚举每个”假设“合法的长度（可以被总长度整除），并通过搜索判断该长度是否真正合法。这里有一点要注意，合法的长度一定比最长的木棒大，比所有的木棒短，因此变得到了合法长度存在的区间；
在假设合法长度确定的同时也就确定了小木棒的数量cnt=sum/len，那么这个就可以作为合法标志的判断条件：在所有的小木棍都用完的情况下拼成了cnt个长度相等的小木棒。
dfs的搜索思路：
枚举长度len；
用之前还没有使用过的小木棍拼凑小木棒；
判断该长度方案是否可行。
剪枝与优化：

在搜索时设置一个fail变量，标记拼接失败的木棍的长度, 避免同样长度的木棒重复搜索
不容易考虑到的是：当该木棍在开头和结尾都不可以使用的时候, 那么该方案就失败了。因此在搜索失败时要进行及时判断处理
可以在一开始时对所有的木棒排序，从大到小，若填上最长的之后没有可以匹配的话，那么这个长度绝对是不合法的。（大块一定比小块需要搜索的次数少）
限制小木棍加入到木棒中的编号，保证加入进来的木棍的长度是递减的（必须先排序）

## BFS

> 广度优先搜索（也称宽度优先搜索，缩写BFS，以下采用广度来描述）是连通图的一种遍历策略。因为它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域

![img](http://www.2cto.com/uploadfile/Collfiles/20160516/20160516092741570.png)

这里展示的是一个无向图，连通即每2个点都有至少一条路径相连，例如V0到V4的路径就是V0->V1->V4。

### 基本思路

常常我们有这样一个问题，从一个起点开始要到一个终点，我们要找寻一条最短的路径，从图2-1举例，如果我们要求V0到V6的一条最短路（假设走一个节点按一步来算）

我们明显看出这条路径就是V0->V2->V6，而不是V0->V3->V5->V6。先想想你自己刚刚是怎么找到这条路径的：首先看跟V0直接连接的节点V1、V2、V3，发现没有V6，进而再看刚刚V1、V2、V3的直接连接节点分别是：{V0、V4}、{V0、V1、V6}、{V0、V1、V5}（这里画删除线的意思是那些顶点在我们刚刚的搜索过程中已经找过了，我们不需要重新回头再看他们了）。这时候我们从V2的连通节点集中找到了V6，那说明我们找到了这条V0到V6的最短路径：V0->V2->V6，虽然你再进一步搜索V5的连接节点集合后会找到另一条路径V0->V3->V5->V6，但显然他不是最短路径。

你会看到这里有点像辐射形状的搜索方式，从一个节点，向其旁边节点传递病毒，就这样一层一层的传递辐射下去，知道目标节点被辐射中了，此时就已经找到了从起点到终点的路径。

初始，V0

![img](http://www.2cto.com/uploadfile/Collfiles/20160516/20160516092741572.png)

已搜索V0，即将搜索V1、V2、V3

![img](http://www.2cto.com/uploadfile/Collfiles/20160516/20160516092741573.png)

……终点V6被染灰色，终止

![img](http://www.2cto.com/uploadfile/Collfiles/20160516/20160516092741575.png)



![img](http://www.2cto.com/uploadfile/Collfiles/20160516/20160516092741577.png)

### 实例

广度优先搜索适用于迷宫类问题，这里先给出[POJ3984](http://poj.org/problem?id=3984)《迷宫问题》。

《迷宫问题》

定义一个二维数组：
{
0,1,0,0,0,
0,1,0,1,0,
0,0,0,0,0,
0,1,1,1,0,
0,0,0,1,0,
};
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。

题目保证了输入是一定有解的。

也许你会问，这个跟广度优先搜索的图怎么对应起来？BFS的第一步就是要识别图的节点跟边

1.识别出节点跟边
节点就是某种状态，边就是节点与节点间的某种规则。

对应于《迷宫问题》，你可以这么认为，节点就是迷宫路上的每一个格子（非墙），走迷宫的时候，格子间的关系是什么呢？按照题目意思，我们只能横竖走，因此我们可以这样看，格子与它横竖方向上的格子是有连通关系的，只要这个格子跟另一个格子是连通的，那么两个格子节点间就有一条边。

如果说本题再修改成斜方向也可以走的话，那么就是格子跟周围8个格子都可以连通，于是一个节点就会有8条边（除了边界的节点）。

2.解题思路
对应于题目的输入数组：

0,1,0,0,0,
0,1,0,1,0,
0,0,0,0,0,
0,1,1,1,0,
0,0,0,1,0,

我们把节点定义为(x,y)，(x,y)表示数组maze的项x,y.

于是起点就是(0,0)，终点是(4,4)。按照刚刚的思路，我们大概手工梳理一遍：

初始条件：

起点Vs为(0,0)

终点Vd为(4,4)

灰色节点集合Q={}

初始化所有节点为白色节点

开始我们的广度搜索！

手工执行步骤【PS：你可以直接看图4-1】:

1.起始节点Vs变成灰色，加入队列Q，Q={(0,0)}

2.取出队列Q的头一个节点Vn，Vn={0,0}，Q={}

3.把Vn={0,0}染成黑色，取出Vn所有相邻的白色节点{(1,0)}

4.不包含终点(4,4)，染成灰色，加入队列Q，Q={(1,0)}

5.取出队列Q的头一个节点Vn，Vn={1,0}，Q={}

6.把Vn={1,0}染成黑色，取出Vn所有相邻的白色节点{(2,0)}

7.不包含终点(4,4)，染成灰色，加入队列Q，Q={(2,0)}

8.取出队列Q的头一个节点Vn，Vn={2,0}，Q={}

9.把Vn={2,0}染成黑色，取出Vn所有相邻的白色节点{(2,1),(3,0)}

10.不包含终点(4,4)，染成灰色，加入队列Q，Q={(2,1),(3,0)}

11.取出队列Q的头一个节点Vn，Vn={2,1}，Q={(3,0)}

12. 把Vn={2,1}染成黑色，取出Vn所有相邻的白色节点{(2,2)}

13.不包含终点(4,4)，染成灰色，加入队列Q，Q={(3,0),(2,2)}

14.持续下去，知道Vn的所有相邻的白色节点中包含了(4,4)……

15.此时获得了答案

 

起始你很容易模仿上边过程走到终点，那为什么它就是最短的呢？

怎么保证呢？

我们来看看广度搜索的过程中节点的顺序情况：![img](http://www.2cto.com/uploadfile/Collfiles/20160516/20160516092741578.png)

你是否观察到了，广度搜索的顺序是什么样子的？

图中标号即为我们搜索过程中的顺序，我们观察到，这个搜索顺序是按照上图的层次关系来的，例如节点(0,0)在第1层，节点(1,0)在第2层，节点(2,0)在第3层，节点(2,1)和节点(3,0)在第3层。

我们的搜索顺序就是第一层->第二层->第三层->第N层这样子。

我们假设终点在第N层，因此我们搜索到的路径长度肯定是N，而且这个N一定是所求最短的。

我们用简单的反证法来证明：假设终点在第N层上边出现过，例如第M层，M

所以根据广度优先搜索的话，搜索到终点时，该路径一定是最短的。

``

```c++
/** 
 * 广度优先搜索 
 * @param Vs 起点 
 * @param Vd 终点 
 */  
bool BFS(Node& Vs, Node& Vd){  
    queue Q;  
    Node Vn, Vw;  
    int i;  
  
    //用于标记颜色当visit[i][j]==true时，说明节点访问过，也就是黑色  
    bool visit[MAXL][MAXL];  
  
    //四个方向  
    int dir[][2] = {  
        {0, 1}, {1, 0},  
        {0, -1}, {-1, 0}  
    };  
  
    //初始状态将起点放进队列Q  
    Q.push(Vs);  
    visit[Vs.x][Vs.y] = true;//设置节点已经访问过了！  
  
    while (!Q.empty()){//队列不为空，继续搜索！  
        //取出队列的头Vn  
        Vn = Q.front();  
        Q.pop();  
  
        for(i = 0; i < 4; ++i){  
            Vw = Node(Vn.x+dir[i][0], Vn.y+dir[i][1]);//计算相邻节点  
  
            if (Vw == Vd){//找到终点了！  
                //把路径记录，这里没给出解法  
                return true;//返回  
            }  
  
            if (isValid(Vw) && !visit[Vw.x][Vw.y]){  
                //Vw是一个合法的节点并且为白色节点  
                Q.push(Vw);//加入队列Q  
                visit[Vw.x][Vw.y] = true;//设置节点颜色  
            }  
        }  
    }  
    return false;//无解  
}  
```

P1443 马的遍历

题目描述
有一个 n \times mn×m 的棋盘，在某个点 (x, y)(x,y) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

输入格式
输入只有一行四个整数，分别为 n, m, x, yn,m,x,y。

输出格式
一个 n \times mn×m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 55 格，不能到达则输出 -1−1）。

输入输出样例
输入 #1复制
3 3 1 1
输出 #1复制
0    3    2    
3    -1   1    
2    1    4    

```c++
#include<cstdio>
#include<queue>
/*
  <queue> 队列头文件
  用到的函数:
    1:队列名称.front();
      返回队列中的第一个元素
    2:队列名称.pop();
      删除队列中的第一个元素
    3:队列名称.empty();
      检查队列是否为空
        若为空,返回 true
        否则返回 false
    4:队列名称.push(...);
      将括号内元素插入到队列末尾
*/
using namespace std;
queue<int> qx,qy,qstep;
/*
  qx队列用来存放 x 坐标
  qy队列用来存放 y 坐标
  qstep队列用来存放 步数
*/
int n,m,X,Y,a[500][500];
/*
  n 为长, m 为宽
  X,Y代表马从哪里开始跳
  a[][]用来存放最终解
*/
bool vis[500][500];
/*
  vis初始为false
  vis用来判断这个点是否走过
    根据广搜的性质,一个点被第一个搜到一定是最优解
*/
int xx[9]={0,-1,-2,-2,-1,1,2,2,1};
int yy[9]={0,-2,-1,1,2,2,1,-1,-2};
/*
  xx[],yy[]表示马的8种跳法所带来 x 轴和 y 轴的变化
*/
void Print(int x)
{
    int Ws=0;
    if(x==0) printf("    ");//特判,0占一位
    else
    {
        while(x>0)
        {
            ++Ws;// 位数+1
            x/=10;// x/=10 相当于将x的最后一位删除
        }
        for(int S=1;S<=5-Ws;++S)//向左对齐,输出 5-位数 个空格
            printf(" ");
    }
}
void bfs()
{
    int x,y,step;
    while(qx.empty()==0)
    {
        x=qx.front();//返回 qx 第一个元素的值
        y=qy.front();//返回 qy 第一个元素的值
        step=qstep.front();//返回 qstep 第一个元素的值
        a[x][y]=step;
        /*
          广搜的最优性质
        */
        qx.pop();qy.pop();qstep.pop();
        /*
          将 qx,qy,qstep 的第一个元素弹出
        */
        for(int i=1;i<=8;++i)
        {
            if(x+xx[i]>=1 && x+xx[i]<=n && y+yy[i]>=1 && y+yy[i]<=m && vis[x+xx[i]][y+yy[i]]==0)
            /*
              判断是否出界 以及该点是否被访问过
            */
            {
                vis[x+xx[i]][y+yy[i]]=1;//该点被访问
                qx.push(x+xx[i]);//压入新的 x 坐标
                qy.push(y+yy[i]);//压入新的 y 坐标
                qstep.push(step+1);//走到该点又要一步
            }
        }
    }
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&X,&Y);//读入
    qx.push(X);//将初始位置 x 坐标压入队列
    qy.push(Y);//将初始位置 y 坐标压入队列
    qstep.push(0);//初始位置只要走 0 步
    vis[X][Y]=1;//坑点,要将初始位置设为走过,否则会出现回跳现象
    bfs();//将任务交给广搜
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
            if(!vis[i][j]) printf("-1   ");//若该点未走到过,则输出 -1 以及3个空格
            else
            {
                printf("%d",a[i][j]);//输出那个数
                Print(a[i][j]);//输出对应的空格数
            }
        printf("\n");//回车
    }
    return 0;
}
```



### 核心代码

```c++
/** 
 * 广度优先搜索 
 * @param Vs 起点 
 * @param Vd 终点 
 */  
bool BFS(Node& Vs, Node& Vd){  
    queue Q;  
    Node Vn, Vw;  
    int i;  
  
    //初始状态将起点放进队列Q  
    Q.push(Vs);  
    hash(Vw) = true;//设置节点已经访问过了！  
  
    while (!Q.empty()){//队列不为空，继续搜索！  
        //取出队列的头Vn  
        Vn = Q.front();  
  
        //从队列中移除  
        Q.pop();  
  
        while(Vw = Vn通过某规则能够到达的节点){  
            if (Vw == Vd){//找到终点了！  
                //把路径记录，这里没给出解法  
                return true;//返回  
            }  
  
            if (isValid(Vw) && !visit[Vw]){  
                //Vw是一个合法的节点并且为白色节点  
                Q.push(Vw);//加入队列Q  
                hash(Vw) = true;//设置节点颜色  
            }  
        }  
    }  
    return false;//无解  
}  
```

对于一个题目来说，要标志节点是否访问过，用数组是一种很快速的方法，但有时数据量太大，很难用一个大数组来记录时，采用hash是最好的做法。实际上visit数组在这里也是充当hash的作用。（PS：至于hash是什么？得自己去了解，它的作用是在O(1)的时间复杂度内取出某个值）

假设图有V个顶点，E条边，广度优先搜索算法需要搜索V个节点，因此这里的消耗是O(V)，在搜索过程中，又需要根据边来增加队列的长度，于是这里需要消耗O(E)，总得来说，效率大约是O(V+E)。

**其实最影响BFS算法的是在于Hash运算，我们前面给出了一个visit数组，已经算是最快的Hash了，但有些题目来说可能Hash的速度要退化到O(lgn)的复杂度，当然了，具体还是看实际情况的。**

**BFS适合此类题目：给定初始状态跟目标状态，要求从初始状态到目标状态的最短路径。**

### 拓展

进而扩展的话就是**双向广度搜索算法**，顾名思义，即是从起点跟终点分别做广度优先搜索，直到他们的搜索过程中有一个节点相同了，于是就找到了起点跟终点的一条路径。

腾讯笔试题目：假设每个人平均是有25个好友，根据六维理论，任何人之间的联系一定可以通过6个人而间接认识，间接通过N个人认识的，那他就是你的N度好友，现在要你编程验证这个6维理论。

此题如果直接做广度优先搜索，那么搜索的节点数可能达到256，如果是用双向的话，两个树分别只需要搜索到3度好友即可，搜索节点最多为253个，但是用双向广度算法的话会有一个问题要解决，就是你如何在搜索的过程中判断第一棵树中的节点跟第二棵树中的节点有相同的呢？按我的理解，可以用Hash，又或者放进队列的元素都是指向原来节点的指针，而每个节点加入一个color的属性，这样再搜索过程中就可以根据节点的color来判断是否已经被搜索过了。

